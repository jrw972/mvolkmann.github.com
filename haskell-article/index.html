<!DOCTYPE html>
<html>
  <head>
    <title>Haskell</title>
    <style type="text/css">
      aside, blockquote {
        border: solid lightgray 2px;
        margin-bottom: 15px;
        margin-left: 0;
        padding: 10px;
      }
      body {
        font-family: sans-serif;
        margin: 20px 40px;
      }
      .center {
        text-align: center;
      }
      code {
        background-color: lightyellow;
        font-weight: bold;
        padding: 3px 2px;
      }
      div {
        margin-bottom: 10px;
      }
      #logo {
        width: 300px;
      }
      h1, h3 {
        color: blue;
      }
      h2 {
        border-top: solid red 3px;
        color: purple;
        padding-top: 20px;
        text-decoration: underline;
      }
      h4 {
        color: purple;
      }
      img {
        margin: 10px 0;
        width: 800px;
      }
      #lscolors {
        width: 200px;
      }
      pre {
        background-color: lightyellow;
        font-weight: bold;
        width: 800px;
      }
      table {
        border-collapse: collapse;
      }
      table caption {
        font-size: 18px;
        font-weight: bold;
        margin: 10px 0 5px 0;
        text-align: left;
      }
      table.operators td:first-child {
        font-family: monospace;
      }
      table.operators td:nth-child(3) {
        font-family: monospace;
      }
      td, th {
        border: solid lightgray 1px;
        padding: 3px 6px;
      }
      .toc > .level1 {
        font-weight: bold;
        margin-left: 0;
        margin-top: 10px;
      }
      .toc > .level2 {
        margin-left: 16px;
      }
      .toc > .level3 {
        font-size: 14px;
        margin-left: 32px;
      }

      @media print {
        margin: 1in;
      }
    </style>
  </head>
  <body>
    <h1>Haskell</h1>
    <div>
      by Mark Volkmann<br>
      <a href="mailto:mark@objectcomputing.com">mark@objectcomputing.com</a><br>
      <a href="http://objectcomputing.com" target="_blank">Object Computing, Inc.</a><br>
      April 2018
    </div>
    <h4>
      Get serious about functional programming!
    </h4>
    <img id="logo" src="haskell-logo.png" alt="Haskell logo">

    <h3>Table of Contents</h3>
    <ul class="toc">
      <li class="level1"><a href="#Overview">Overview</a></li>
      <li class="level2"><a href="#WhyLearn">WhyLearn</a></li>
      <li class="level2"><a href="#LearningResources">LearningResources</a></li>
      <li class="level2"><a href="#History">History</a></li>

      <li class="level1"><a href="#Compilers">Compilers</a></li>
      <li class="level2"><a href="#GHC">Glasgow Haskell Compiler (GHC)</a></li>
      <li class="level2"><a href="#ghci">ghci</a></li>
      <li class="level2"><a href="#GhcExecutables">GhcExecutables</a></li>
      <li class="level2"><a href="#Stack">Stack tool</a></li>

      <li class="level2"><a href="#Libraries">Libraries</a></li>
      <li class="level2"><a href="#Tools">Tools</a></li>
      <li class="level2"><a href="#SourceFiles">Source Files</a></li>

      <li class="level1"><a href="#Names">Names</a></li>
      <li class="level1"><a href="#Types">Types</a></li>
      <li class="level2"><a href="#PreludeTypes">Prelude Types</a></li>
      <!-- Include Unit () -->
      <li class="level2"><a href="#TypeSignatures">Type Signatures</a></li>
      <li class="level2"><a href="#ClassConstraints">Class Constraints</a></li>
      <li class="level2"><a href="#TypeInference">Type Inference</a></li>
      <li class="level2"><a href="#TypeClasses">Type Classes</a></li>
      <!-- Include default implementations -->
      <li class="level2"><a href="#TypeAliases">Type Aliases</a></li>
      <li class="level2"><a href="#TypeInstances">Type Instances</a></li>
      <li class="level2"><a href="#TypeConstructors">Type Constructors</a></li>
      <li class="level2"><a href="#Algebraic Data Types">Algebraic Data Types</a></li>
      <!-- Include constructors with arguments -->
      <li class="level2"><a href="#Deriving">Deriving</a></li>

      <li class="level1"><a href="#Operators">Operators</a></li>
      <li class="level2"><a href="#OperatorBasics">Basics</a></li>
      <li class="level2"><a href="#Precedence">Precedence</a></li>
      <li class="level2"><a href="#Associativity">Associativity</a></li>
      <li class="level2"><a href="#Sections">Sections</a></li>

      <li class="level1"><a href="#Variables">Variables</a></li>

      <li class="level1"><a href="#Functions">Functions</a></li>
      <li class="level2"><a href="#FunctionBasics">Basics</a></li>
      <li class="level2"><a href="#Currying">Currying</a></li>
      <li class="level2"><a href="#Recursion">Recursion</a></li>
      <li class="level2"><a href="#FunctionComposition">Function Composition</a></li>
      <li class="level2"><a href="#ArgumentCapture">ArgumentCapture</a></li>
      <li class="level2"><a href="#PatternMatching">Pattern Matching</a></li>
      <li class="level2"><a href="#Guards">Guards</a></li>
      <li class="level2"><a href="#LambdaFunctions">Lambda Functions</a></li>
      <li class="level2"><a href="#HigherOrderFunctions">Higher Order Functions</a></li>

      <li class="level1"><a href="#DataStructures">Data Structures</a></li>
      <li class="level2"><a href="#Lists">Lists</a></li>
      <li class="level3"><a href="#ListBasics">Basics</a></li>
      <li class="level3"><a href="#ListComprehension">List Comprehension</a></li>
      <li class="level3"><a href="#Ranges">Ranges</a></li>
      <li class="level3"><a href="#AssociationLists">Association Lists</a></li>

      <li class="level2"><a href="#Tuples">Tuples</a></li>
      <li class="level3"><a href="#"></a></li>

      <li class="level2"><a href="#Records">Records</a></li>
      <li class="level3"><a href="#RecordBasics">Basics</a></li>
      <li class="level3"><a href="#RecordUpdating">Updating</a></li>

      <li class="level2"><a href="#Arrays">Arrays</a></li>
      <li class="level2"><a href="#Maps">Maps</a></li>

      <li class="level1"><a href="#Modules">Modules</a></li>
      <li class="level2"><a href="#Importing">Importing</a></li>
      <li class="level2"><a href="#QualifiedImports">Qualified Imports</a></li>
      <li class="level2"><a href="#Exclusions">Exclusions</a></li>
      <li class="level2"><a href="#Exporting">Exporting</a></li>

      <li class="level1"><a href="#Syntax">Syntax</a></li>
      <li class="level2"><a href="#EvaluationOrder">Evaluation Order</a></li>
      <li class="level2"><a href="#Comments">Comments</a></li>
      <li class="level2"><a href="#ReservedWords">Reserved Words</a></li>
      <li class="level2"><a href="#StringsAndCharacters">Strings &amp; Character</a></li>
      <li class="level2"><a href="#Numbers">Numbers</a></li>
      <li class="level2"><a href="#DatesAndTimes">Dates and Times</a></li>
      <li class="level2"><a href="#Enumerations">Enumerations</a></li>
      <!-- include deconstruction -->
      <li class="level2"><a href="#IfThenElse">If Then Else</a></li>
      <li class="level2"><a href="#Case">Case</a></li>
      <li class="level2"><a href="#Let">Let</a></li>
      <li class="level2"><a href="#Where"></a></li>

      <li class="level1"><a href="#InputOutput">Input/Output</a></li>
      <li class="level2"><a href="#DoBlocks">Do Blocks</a></li>
      <li class="level2"><a href="#CommandLineArguments">Command Line Arguments</a></li>
      <li class="level2"><a href="#Files">Files</a></li>
      <li class="level2"><a href="#Streams">Streams</a></li>
      <li class="level2"><a href="#Bytestrings">Bytestrings</a></li>

      <li class="level1"><a href="#ExceptionHandling">Exception Handling</a></li>

      <li class="level1"><a href="#AdvancedTopics">Advanced Topics</a></li>
      <li class="level2"><a href="#Monoids">Monoids</a></li>
      <li class="level2"><a href="#Monads">Monads</a></li>
      <li class="level2"><a href="#Functors">Functors</a></li>
      <li class="level2"><a href="#Applicatives">Applicatives</a></li>
      <li class="level2"><a href="#Foldables">Foldables</a></li>
      <li class="level2"><a href="#Traversables">Traversables</a></li>
      <li class="level2"><a href="#Combinators">Combinators</a></li>
      <li class="level2"><a href="#Transducers">Transducers</a></li>
      <li class="level2"><a href="#Lenses">Lenses</a></li>
      <li class="level2"><a href="#HigherKindedTypes">Higher Kinded Types</a></li>

      <li class="level1"><a href="#Summary">Summary</a></li>
      <li class="level1"><a href="#Acknowledgments">Acknowledgments</a></li>
    </ul>

    <h3><a name="Overview">Overview</a></h3>
    <div>
      Haskell is a functional programming language.
      It's primary characteristics are that it:
    </div>
    <ul>
      <li>is purely functional, not supporting
        procedural or object-oriented programming</li>
      <li>supports first-class functions that can be
        passed to and returned from other functions</li>
      <li>only supports immutable data (cannot be modified)</li>
      <li>strictly separates impure functions (those with side effects)
        from pure functions</li>
      <li>is statically typed with type inference</li>
      <li>is lazy meaning that expressions are not evaluated
        until their value is needed</li>
      <li>has no "for" or "while" loops;
        instead iteration is performed with recursion and functions like
        <code>map</code>, <code>filter</code>, and <code>foldl</code></li>
      <li>has a powerful type system</li>
      <li>uses persistent data structures to efficiently
        create modified copies of existing data structures</li>
      <li>addresses
        <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)">Concurrency</a>
        and
        <a href="https://en.wikipedia.org/wiki/Parallel_computing">parallelism</a>
        </li>
    </ul>
    <div>
      TODO: Get more from Wikipedia page!
    </div>
    <div>
      This article is targeted at software developers that
      have not yet been exposed to the Haskell programming language
      and want to quickly learn why so many developers love it.
      The goal is to provide something that is more detailed than
      a cheatsheet and less detailed than a book.
    </div>

    <h4><a name="WhyLearn">Why Learn Haskell?</a></h4>
    <div>
      There are many reasons to learn Haskell including:
    </div>
    <ul>
      <li>It can be fun and challenging to learn a new programming language.</li>
      <li>It's good learn about the functional style of programming
        if you have only primarily used procedural or object-oriented programming.</li>
      <li>Learning Haskell will give you a greater appreciation of types.</li>
      <li>Haskell inspired the design of the Elm programming language,
        so learning Haskell is a step toward learning Elm.</li>
      <li>PureScript can be used to compile most Haskell code to JavaScript,
        so it can be used to develop Node apps and web apps.</li>
      <li>It may cause you to thinking about programming in other languages in a new, better way.</li>
      <li>You may actually decide to write an appliation in Haskell.</li>
      <li>And finally, you may decide you do not like Haskell.
        That's fine, but you'll want to be able to explain why
        and that requires learning some things about the language.</li>
    </ul>

    <h3><a name="LearningResources">Learning Resources</a></h3>
    <div>
      There are many resources for learning Haskell.
      Many of them are much longer and more technical that this article.
      I suggest starting here and then moving on to the following resources:
    </div>
    <ul>
      <li>"Learn You a Haskell for Great Good!" book -
        This can be purchased or read online at
        <a href="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a>.
        (360 pages)
      </li>
      <li>"Programming in Haskell" book -
        <a href="http://www.cs.nott.ac.uk/~pszgmh/pih.html">http://www.cs.nott.ac.uk/~pszgmh/pih.html</a>.
      </li>
      <li>"Real World Haskell" book -
        This can be purchased or read online at
        <a href="http://book.realworldhaskell.org/">http://book.realworldhaskell.org/</a>.
      </li>
      <li>Haskell Homepage
        <a href="https://www.haskell.org/">https://www.haskell.org/</a>
      </li>
      <li>Haskell Wiki
        <a href="https://wiki.haskell.org/">https://wiki.haskell.org/</a>
      </li>
      <li>Haskell WikiBook
        <a href="https://en.wikibooks.org/wiki/Haskell">https://en.wikibooks.org/wiki/Haskell</a>
      </li>
      <li>Hoogle - Haskell API search engine
        <a href="https://www.haskell.org/hoogle/">https://www.haskell.org/hoogle/</a>
      </li>
      <li>Lecture series based on "Programming in Haskell" book by Erik Meijer
        <a href="https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/">https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/</a>
      </li>
    </ul>

    <h4><a name="History">History</a></h4>
    <div>
      The Haskell programming language was named after
      the American mathmatician Dr. Haskell Brooks Curry (1900-1982).
      He was a Harvard graduate, known for his work in combinatory logic.
      Dr. Curry taught at Harvard, Princeton, Penn State,
      and the University of Amsterdam.
      Interestingly there are three programming languages named after him,
      Haskell, Brook, and Curry.
      Of the three, Haskell is by far the most popular.
    </div>
    <div>
      Work on Haskell started in 1987.
      It was designed by a committee that at various times included
      Simon Peyton Jones, Erik Meijer, and Philip Wadler.
      Haskell was first released in 1990.
      The language was standardized in 1999 as "Haskell 98",
      and revised in 2003.
      The current version of the standard, released in 2010,
      is called "Haskell 2010".  Among other things this added
      the LANGUAGE pragma and
      a foreign function interface (FFI) for calling C code
      A committee of about 20 members is working on the next version,
      "Haskell 2020".
    </div>

    <h3><a name="Compilers">Compilers</a></h3>
    <div>
      There are many Haskell compilers that produce executables from Haskell source code.
      The most popular is the Glasgow Haskell Compiler
      (<a href="https://www.haskell.org/ghc/">GHC</a>).
      Other include the Utrecht Haskell Compiler
      (<a href="http://foswiki.cs.uu.nl/foswiki/UHC">UHC</a>)
      and the LLVM Haskell Compiler
      (<a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM">LHC</a>)
      which is included with GHC.
    </div>
    <div>
      There are also dialects of Haskell that include:
    </div>
    <ul>
      <li>Disciple
        <a href="http://disciple.ouroborus.net/">http://disciple.ouroborus.net/</a>
        "an experimental dialect of Haskell which investigates static typing
        and program transformation in the presence of computational effects."
      </li>
      <li>Frege
        <a href="https://github.com/Frege/frege">https://github.com/Frege/frege</a>
        "a Haskell for the JVM"
      </li>
      <li>PureScript
        <a href="http://www.purescript.org/">http://www.purescript.org/</a>
        "a strongly-typed functional programming language
        that compiles to JavaScript"
      </li>
      <li>Eta
        <a href="http://eta-lang.org/">http://eta-lang.org/</a>
        "A simple &amp; powerful language for
        building scalable systems on the JVM"
        "It brings two big ecosystems i.e., Java and Haskell together.
        This means that you can reuse Java and Haskell libraries
        in Eta projects."
      </li>
    </ul>

    <h4><a name="GHC">Glasgow Haskell Compiler (GHC)</a></h4>
    <div>
      The latest stable version of the GHC compiler
      at the time of this article was 8.2.1.
      The license for GHC can be found at
      <a href="https://www.haskell.org/ghc/license.html">https://www.haskell.org/ghc/license.html</a>.
    </div>
    <div>
      One complaint about GHC is that it has cryptic error messages.
      Another is that it produces executables that are larger
      than those produces by compilers for other languages
      for similar applications.
    </div>
    <div>
      Instructions for installing the GHC compiler are at
      <a href="http://hackage.haskell.org/platform/">http://hackage.haskell.org/platform/</a>.
      There are two options for installing in macOS.
      You can download .dmg file and double-click it.
      You can also use Homebrew and run
      <code>brew cask install haskell-platform</code>.
    </div>
    <div>
      I highly recommend installing GHC now
      so you can try each code example in this article.
    </div>

    <h4><a name="ghci">ghci</a></h4>
    <div>
      GHC comes with a "read-evaluate-print-loop" (REPL) tool called ghci
      for experimenting with Haskell code.
      It's a great tool, especially when just getting started with Haskell.
      To start it, enter <code>gchi</code>.
      To get help on commands, enter <code>:help</code> or <code>:?</code>.
      To exit, press ctrl-d or enter <code>:quit</code>.
      Previously entered commands can be recalled using the up and down arrow keys.
    </div>
    <div>
      The default prompt is <code>Prelude></code>.
      This is the name of the standard library that is automatically loaded.
      To change the prompt within the current session, enter
      <code>:set prompt "new prompt"</code>.
      To make this a permanent change that is used in all future ghci sessions,
      add that command to the file <code>~/.ghci</code>.
      Mine uses an elephant emoji for the elephant on the
      cover of the book "Learn You a Haskell for Great Good!".
    </div>
    <div>
      To enable Vim keybindings inside ghci,
      create the file <code>~/.haskeline</code>
      and add the command <code>editMode: Vi</code> to it.
    </div>
    <div>
      When Haskell expressions are entered in ghci,
      they are evaluated the their value is printed
      by calling <code>show</code> on it which
      converts many kinds of values to a string representation.
    </div>
    <div>
      Besides entering Haskell expressions,
      there are many commands that can be entered,
      all preceded by a colon.
      The most useful of these include:
    </div>
    <ul>
      <li><code>:browse <i>module-name</i></code> lists the exported functions</li>
      <li><code>:edit</code> edits the last module loaded with the default editor<br>
        (automatically reloads file after editor exits)</li>
      <li><code>:edit <i>file-path</i></code> edits the specified file with the default editor</li>
      <li><code>:help</code> or <code>:?</code> outputs ghci help</li>
      <li><code>:info <i>fn-name</i></code> outputs information about a function</li>
      <li><code>:load <i>file-path</i></code> loads a module definition and all modules it imports</li>
      <li><code>:main <i>args</i></code> runs the main function</li>
      <li><code>:quit</code> exits ghci; can also press ctrl-d</li>
      <li><code>:script <i>file-path</i></code> runs a script which is a file containing Haskell expressions
        rather than a module definition as is loaded with the <code>:load</code> command</li>
      <li><code>:type <i>name</i></code> outputs the type of a name</li>
      <li><code>:reload</code> reloads the last loaded file</li>
      <li><code>:set +t</code> turns on automatically outputting the type of all expressions entered</li>
      <li><code>:unset +t</code> turns off automatically outputting types</li>
      <li><code>:show modules</code> lists all modules that have been imported</li>
      <li><code>:!<i>command</i></code> runs a shell command; For example, :!clear clears the screen.</li>
    </ul>
    <div>
      Many commands can be abbreviated to a colon followed by the first letter.
      These include <code>:edit</code>, <code>:help</code>, <code>:info</code>,
      <code>:load</code>, <code>:quit</code>, <code>:reload</code>, and <code>:type</code>.
    </div>
    <div>
      ghci has a builtin debugger supported by many colon commands.
      Enter <code>:help</code> to see a list of them.
    </div>
    <div>
      All functions defined in the Prelude module are available by default in ghci.
      To use functions in other modules, import them by entering
      <code>import <i>module-name</i></code>.
    </div>
    <div>
      Inside ghci, to see all the functions defined in a module,
      enter the module name followed by a period and press tab for completion.
      For example, enter <code>import Data.Map</code>,
      enter <code>Data.Map.</code>, and press tab.
    </div>

    <h4><a name="GhcExecutables">GHC Executables</a></h4>
    <pre>
- create a .hs file with a "main" function
- ghc {name}.hs
  * produces two intermediate files
  * .hi is an interface file
    - a binary file containing:
      * details about the compilation including the GHC version
      * list of exports including their types, arity, and strictness
    - can be viewed with
      ghc --show-iface name.hi
  * .o is an object file
    - a binary file containing compiled code
- run with ./name
- example
  * in file greet.hs
    import System.IO
    main = do
      -- lines inside do must have the same indentation
      putStrLn "Enter your name."
      name <- getLine
      putStrLn ("Hello, " ++ name ++ "!")
  * ghc greet
  * ./greet
- example that uses a command-line argument
  * see fact.hs in your Haskell directory
    </pre>

    <h4><a name="Stack">Stack tool</a></h4>
    <div>
      "Stack is a cross-platform program for developing Haskell projects."
      The primary website for this tool is
      <a href="https://docs.haskellstack.org/">https://docs.haskellstack.org/</a>.
      Stack provides many capabilities beyond an older Haskell build tool
      called "Cabal" which it uses.
      It also uses GHC.
      Stack can:
    </div>
    <ul>
      <li>generate a scaffold (initial directories and files) for a new project</li>
      <li>manage package dependencies</li>
      <li>build an application</li>
      <li>run tests</li>
      <li>report code coverage</li>
      <li>and more?</li>
    </ul>
    <div>
      To install Stack on a *nix system, enter
      <code>curl -sSL https://get.haskellstack.org/ | sh</code>.
      To install on a Mac, install Homebrew and enter <code>brew install haskell-stack</code>.
      To install in windows, download an installer from the Stack website.
      To upgrade the version that is installed, enter <code>stack upgrade</code>.
    </div>
    <div>
      To create a new project enter
      <code>stack new <i>project-name</i></code>.
      This creates a directory with the same name as the project
      containing many files that provide scaffolding for an application.
      Change to this directory before executing other stack commands.
      The file <code>app/Main.hs</code> imports <code>src/Lib.hs</code>
      which defines the function <code>someFunc</code>
      and it calls that function.
      The file <code>test/Spec.hs</code> provides a starting point
      for implementing unit tests.
    </div>
    <div>
      The file <code>package.yaml</code> describes the project
      and its dependencies.
      For those familiar with Node.js, this file is very similar
      to <code>package.json</code> files.
    </div>
    <div>
      To download and install GHC inside the project
      enter <code>stack setup</code>.
      This allows each project to use a different version of GHC.
    </div>
    <div>
      To build the project enter <code>stack build</code>.
      This creates an executable below the <code>.stack-work</code> directory.
      It doesn't do anything if no source files required to build the executable
      have been modified since the last build.
    </div>
    <div>
      To run the project enter <code>stack exec <i>project-name</i>-exe</code>.
      For a new project this will simply output "someFunc".
      If you would rather not have "-exe" at the end of the executable name,
      edit <code>package.yaml</code> and remove <code>-exe</code>
      from the name of the first child under <code>executables:</code>.
    </div>
    <div>
      To install the project enter <code>stack install</code>.
      This creates an executable in the directory $HOME/.local/bin.
      Add this directory to the PATH environment variable to enable
      running installed applications by simplying entering the project name.
    </div>
    <div>
      Stack uses GHC to create executables.
      By default it does not use the <code>-dynamic</code> option.
      This results in very large executables.
      The scaffold application executable is just over one megabyte.
      To get stack to run GHC with the <code>-dynamic</code> option,
      edit <code>package</code> and add it under the path
      executables...<i>project-name</i>-exe...ghc-options.
      The size of the scaffold application executable
      is reduced to under 13K with this option (1.2%)!
    </div>
    <div>
      To run the project tests enter <code>stack test</code>.
      This does not use a specific test framework.
      Any can be used.  A popular choice is
      <a href="https://hspec.github.io/">hspec</a>.
      See the hspec section later.
    </div>
    <div>
      To start a REPL enter <code>stack ghci</code>
      or <code>stack repl</code> which is an alias.
      You will likely use this often, so consider creating
      an alias for this command with a short name
      like "hr" for "Haskell REPL".
    </div>
    <div>
      To delete all generated files, including executables
      created by the <code>stack build</code> command,
      enter <code>stack clean</code>.
      This deletes some files under the <code>.stack-work</code> directory,
      but you can also just delete that entire directory.
      The <code>.stack-work</code> directory is listed
      in the generated <code>.gitignore</code> file.
    </div>
    <div>
      To list the project dependencies enter <code>stack list-dependencies</code>.
    </div>
    <div>
      To perform an API search using Hoogle,
      enter <code>stack list-dependencies</code>.
      The first time this is used it will install over 100 libraries
      and run for almost ten minutes!
      It is much faster after that.
      For example, to find functions that have the word "sort" in their name,
      enter <code>stack hoogle sort</code>.
      To find functions that take a list and return a boolean value,
      enter <code>stack hoogle "[a] -> Bool"</code>.
    </div>
    <div>
      To install a package, enter <code>stack install <i>package-name</i></code>.
      This does not add a dependency to the <code>package.yaml</code> file.
    </div>
    <div>
      To see all the stack options and commands, enter <code>stack</code>.
      Commonly used stack commands not already covered include:
      TODO: List any more?
    </div>
    <div>
      Stack has templates for generating many other files.
      To see a list of these enter <code>stack templates</code>.
      Some of the more useful templates include:
    </div>
    <ul>
      <li><code>stack ghcjs</code> - compiles Haskell code to JavaScript</li>
      <li><code>stack hspec</code> - does something with tests</li>
      <li><code>stack scotty-hello-world</code> - does something with REST services?</li>
      <li><code>stack spock</code> - does something with this web framework</li>
      <li><code>stack yesod-mysql</code> - does something with this web framework</li>
    </ul>

    <h4><a name="Libraries">Libraries</a></h4>
    <div>
      A Haskell "library" is a collection of modules.
      A Haskell "module" is a source file that typically
      defines functions, type classes, and types.
    </div>
    <div>
      Haskell software libraries can be found at
      <a href="http://hackage.haskell.org/">http://hackage.haskell.org/</a>.
      Are there other popular sites?
    </div>
    <ul>
      <li>Hackage -
        "the Haskell community's central package archive of open source software"
        <a href="https://hackage.haskell.org/">https://hackage.haskell.org/</a>
      </li>
      <li>Stackage -
        "a stable source of Haskell packages"
        <a href="https://www.stackage.org/">https://www.stackage.org/</a>
      </li>
    </ul>
    <div>
      Some popular Haskell libraries include:
    </div>
    <ul>
      <li>scotty for implementing REST services</li>
      <li>aeson for working with JSON</li>
      <li>? for working with MySQL</li>
      <li>? for working with Postgresql</li>
      <li></li>
    </ul>
    <pre>
- array
- base
- binary
- bytestring
- containers
- deepseq
- directory
- filepath
- ghc
- ghc-boot
- ghc-compact
- ghc-prim
- hoopl
- hpc
- integer-gmp
- process
- template-haskell
- time
- unix
- Win32
    </pre>

    <h3><a name="Tools">Tools</a></h3>

    <div>
      Library installing tools for Haskell include:
    </div>
    <ul>
      <li>Cabal at
        <a href="https://www.haskell.org/cabal/">https://www.haskell.org/cabal/</a>
        "is a system for building and packaging Haskell libraries and programs"
      </li>
      <li>hpack at ?
        for managing dependencies in a <code><i>project-name</i>.cabal</code> file.</li>
      <li>Stack at
        <a href="https://haskellstack.org">https://haskellstack.org</a>
        "is a cross-platform program for developing Haskell projects"
        This uses Cabal.
        To install in Linux and macOS, enter
        <code>curl -sSL https://get.haskellstack.org/ | sh</code>.
        To install other Haskell-related tools using stack, enter
        <code>stack install ghc-mod hlint hdevtools hfmt</code>.
      </li>
    </ul>

    <div>
      Editor plugins for Haskell include:
    </div>
    <ul>
      <li>ALE for Vim at
        <a href="https://github.com/w0rp/ale">https://github.com/w0rp/ale</a>
        provides automatic linting of Haskell code using
        <a href="https://github.com/ndmitchell/hlint">HLint</a>.
        See http://monicalent.com/blog/2017/11/19/haskell-in-vim/!
        Install the Vim plugin vimproc from
        https://github.com/Shougo/vimproc.vim.
        cd to the vimproc directory and run "make".
        Install the Vim plugin ghcmod-vim from
        https://github.com/eagletmt/ghcmod-vim.
        Add these lines to .vimrc:
        nnoremap &lt;Leader&gt;ht :GhcModType&lt;cr&gt;
        nnoremap &lt;Leader&gt;htc :GhcModTypeClear&lt;cr&gt;
        Press ,ht to see type of name under cursor.
        Press ,htc to clear type display.
        Press ,? to show the error message in the status line
        in a multi-line buffer so it is easier to read long messages.
        Other commands include
        :GhcModCheck displays messages in quickfix window.
        :GhcModLint displays messages in quickfix window.
        :GhcModCheckAsync, :GhcModLintAsync, :GhcModCheckAndLintAsync
        and more described at https://github.com/eagletmt/ghcmod-vim.
      </li>
    </ul>

    <div>
      Code formatting tools for Haskell include:
    </div>
    <ul>
      <li>hfmt<br>
        To install this, enter <code>stack install hfmt</code>.
        To format a file, enter <code>hfmt -w <i>filepath</i></code>.
        Can you run this inside Vim?
      </li>
      <li>hindent<br>
      <pre>
- setup
  stack install
  stack install hindent
  add ~/.local/bin to PATH
  hindent {file-path}
  * modifies file in place
  * gives "Parse error" and doesn't modify the file
    if there is a syntax error
- Vim configuration
  * browse https://github.com/alx741/vim-hindent
  * create the directory ~/.vim/ftplugin/haskell
  * save the file hindent.vim there
  * add this .vimrc
    let g:hindent_on_save = 1
  * may only work in a newly created shell
      </pre>
      </li>
      <li>brittany<br>
        To install this,
        <code>git clone https://github.com/lspitzner/brittany.git<br>
        cd brittany<br>
        stack install</code>.<br>
        To format a file, enter
        <code>brittany -i <i>filepath</i> -o <i>filepath</i></code>.
        Can you run this inside Vim?
      </li>
    </ul>

    <div>
      Linting tools for Haskell include:
    </div>
    <ul>
      <li>hlint<br>
        Install this using stack.
        To lint a file, enter <code>hlint <i>filepath</i></code>.
      </li>
    </ul>

    <div>
      Testing tools for Haskell include:
    </div>
    <ul>
      <li>Hspec at
        <a href="https://hspec.github.io/">https://hspec.github.io/</a>
      </li>
      <li>QuickCheck at
        <a href="https://github.com/nick8325/quickcheck">https://github.com/nick8325/quickcheck</a> and
        <a href="https://www.fpcomplete.com/blog/2017/01/quickcheck">https://www.fpcomplete.com/blog/2017/01/quickcheck</a>
      </li>
      <li>test-framework at
        <a href="https://batterseapower.github.io/test-framework/">https://batterseapower.github.io/test-framework/</a>
      </li>
    </ul>

    <h4><a name="hspec">hspec</a></h3>
    <div>
      Perhaps the most popular test library for Haskell is hspec.
      Its user manual can be found at
      <a href="https://hspec.github.io/">https://hspec.github.io/</a>.
    </div>
    <div>
      To use hspec in a project created with stack,
      edit <code>package.yaml</code> and add a line containing "- hspec"
      below tests...<i>project-name</i>-test...dependencies.
    </div>
    <div>
      Here is a simple example of an hspec test
      in the file <code>test/Spec.hs</code>:
    </div>
    <pre>
module Main where

import Lib -- exports the function double
import Test.Hspec

main :: IO ()
main = hspec $
  describe "my suite" $ do
    it "can add" $ do
      (0 + 0) `shouldBe` 0
      (0 + 1) `shouldBe` 1
      (1 + 2) `shouldBe` 3

    it "can subtract" $ (3 - 1) `shouldBe` 2

    it "double" $ double 3 `shouldBe` 6</pre>
    <div>
      To run the tests, enter <code>stack test</code>.
      During development tests typically need to be run repeatedly.
      The best way to do this is to
      load them into ghci (ex. stack ghci test/Spec.hs)
      and use the :reload and :main commands to reload and rerun them.
    </div>

    <h4><a name="SourceFiles">SourceFiles</a></h3>
    <div>
      Haskell source files have a file extension of <code>.hs</code>.
      To load these into a ghci session, enter
      <code>:load <i>filename</i></code> or <code>:l <i>filename</i></code>.
      The <code>.hs</code> file extension can be omitted.
      If a loaded source file is modified, enter
      <code>:reload</code> or <code>:r</code> to reload it in ghci.
      Note that these source files must define a valid Haskell module.
      They are not merely a series of expressions to be evaluated by ghci.
      To make it easy to demonstrate
      use of functions defined in the module,
      consider defining a function with a name like "demo"
      that can be called from ghci.
    </div>
    <div>
      Is it fair to say that ghci always evaluates expressions
      in a monadic context, so "do" is not needed?
    </div>
    <div>
      To execute a Haskell source file without saving intermediate files
      or an executable, enter <code>runghc <i>filename</i></code>.
      The <code>.hs</code> file extension can be omitted.
      Note that <code>runhaskell</code> is an alias (symbolic link)
      for <code>runghc</code>.
    </div>
    <div>
      For example, create file <code>hello.hs</code>
      containing this function definition:
    </div>
    <pre>
hello name = "Hello, " ++ name + "!"</pre>
    <div>
      To run this inside the GHC REPL,
      enter <code>ghci</code>,
      <code>:l hello</code>, and
      <code>hello "Mark"</code>.
    </div>
    <div>
      Functions can call other functions defined later in a source file.
    </div>

    <h3><a name="Names">Names</a></h3>
    <pre>
- variable identifiers start with a lowercase letter
- constructor identifiers with an uppercase letter
- both can contain underscores, single quotes, letters and digits
- operators are formed from one or more of '!#$%&*+./<=>?@\^|-~'
- constructors can be operator names, if they start with a ':'
  - ex. :+ for Data.Complex
    </pre>

    <h3><a name="Types">Types</a></h3>

    <h4><a name="PreludeTypes">Prelude Types</a></h4>
    <div>
      By default the standard module <code>Prelude</code>
      is imported into all Haskell modules.
      However, if a module contains any explicit imports
      or the NoImplicitPrelude extension is enabled,
      <code>Prelude</code> is not automatically imported.
      For details on what the Prelude module defines, see
      <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html">https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html</a>.
    </div>
    <div>
      There are essential four categories of primitives in Haskell.
      They are booleans, characters, strings, and numbers.
      These are supported by the types <code>Bool</code>,
      <code>Char</code>, <code>String</code>, and
      several numeric types defined in the <code>Prelude</code> module.
    </div>
    <div>
      Booleans are represented by the type <code>Bool</code>.
      The only valid values are <code>True</code> and <code>False</code>.
    </div>
    <div>
      Single Unicode characters are represented by the type <code>Char</code>.
      Literal values are surrounded by single quotes.
    </div>
    <div>
      Strings are represented by the type <code>String</code>
      which is a alias for the type <code>[Char]</code>.
      Literal values are surrounded by double quotes.
      Strings are actually <code>List</code>s of <code>Char</code> values,
      so they can be passed to any function that accepts a list
      where the element type is allowed to be <code>Char</code>.
    </div>
    <div>
      Numbers are represented by many types.<br>
      The <code>Int</code> type represents integers in four bytes.<br>
      The <code>Integer</code> type represents arbirtrary precision integers.<br>
      The <code>Float</code> type represents floating point numbers in four byte.<br>
      The <code>Double</code> type represents floating point numbers in eight bytes.<br>
      The <code>Rational</code> type represents ?.<br>
      The <code>Word</code> type represents ?.<br>
    </div>
    <div>
      Many type classes describe the functions supported by numeric types.
      These include:
      Num
      Real
      Integral
      Floating
      RealFrac
      RealFloat
    </div>
    <pre>
  * Num
    - for types that can be used as numbers
    - builtin types that implement this are
      Int, Integer, Float, and Double
    - when a function type signature says that
      two or more parameters have a type of Num,
      those must have the same actual type
      * ex. add :: (Num a) => a -> a -> a
        add a b = a + b
        n = 3 :: Int
        add n 7.2 -- error because n and 7.2 are not the same type
  * Floating
    - the Float and Double types implement this
    - some math functions take arguments of this type (ex. sqrt and sin)
    - ex.
      n = 3 :: Int
      sqrt n -- error because n is not Floating
  * Integral
    - the Int and Integer types implement this
    - fromIntegral function takes an Integral and converts it to Num
      * needed in order to call a function like + on an Integral and a Floating
      * ex. length [1,2,3] + 2.1 raises an error because
        length returns an Int and 2.1 is not an Int
    </pre>
    <pre>
    The functions defined in the Prelude module
    that operate on numbers include
    even, odd, gcd, lcm, ^, ^^, fromIntegral, and realToFrac.
    </pre>
    <div>
      Negative numbers must be surrounded by parentheses to
      indicate that the dash is not the subtraction operator.
      For example, <code>5 - (-2) == 7</code>.
    </div>
    <div>
      The number types exist in a type hierarchy shown in the following diagram.
    </div>
    <img src="number-hierarchy.png" alt="number hierarchy">
    <pre>
  * Num
    * Fractional
      * Floating
        * Float
        * Double
      * RealFrac
        * Float
        * Double
    * Real derives from Ord which adds ordering functions
      * Integral derives from Enum
        * Int
        * Integer
      * RealFrac
        * Float
        * Double
  * RealFloat derives from RealFrac and Floating
    * Float
    * Double
  * Complex
    </pre>
    <div>
      Say something about the Unit () type.
    </div>

    <h4><a name="TypeSignatures">Type Signatures</a></h4>
    <div>
      Haskell type declarations use the Hindley-Milner type system.
      The syntax is <code><i>name</i> :: <i>type</i> </code>
      where <code>::</code> means "has type of".
    </div>
    <pre>
- variable examples
  * firstName :: String
  * names :: [String]
    - an array of Strings
- function examples
  * add :: Int -> Int -> Int
    add x y = x + y
    - each parameter type is followed by ->
      with the return type at the end
    - takes two Ints and returns an Int
    - also takes one Int and returns a
      function that takes and Int and returns an Int
  * type variables can be used to specify that
    an argument type or the return type can be
    any type or a type that derives from a specific type class
    - ex. the swap function below takes any kind of list
      and returns a new list where the first two items are swapped
      swap :: [a] -> [a]
      swap (first:second:rest) = second:first:rest
      swap [1,2,3,4] == [2,1,3,4]
  * to restrict a type variable to types that
    derive from a given type class (not an actual type!)
      swap :: Num n => [n] -> [n]
      swap (first:second:rest) = second:first:rest
      swap [1,2,3,4] == [2,1,3,4]
  * add :: Num a => a -> a -> a -- syntax only works with type classes
    - means all occurrences of a in the signature have type Num
    - takes two Num arguments and returns a Num
    - "a" here is called a "type alias"
    - => and the part to its left is called a "class constraint"
      * if more than one, surround with parens and separate with commas
      * ex. (Num a, String b) =>
    - can require a type variable to derive from more than one type class
      * ex. (Eq a, Ord a) =>
  * add x y = x + y
    - implementation of the two function declarations
  * ghci detail
    - entering the type signature and definition on two lines doesn't work
    - workarounds
      * enter them on same line separated by a semicolon
        - ex. let add :: Num a => a -> a -> a; add x y = x + y
      * enter them in a block
        :{
        let add :: Num a => a -> a -> a
            add x y = x + y -- indented 4 spaces
        :}
      * turn on multline mode which automatically infers use of :{ and :}
        :set +m -- one tie
        let add :: Num a => a -> a -> a
            add x y = x + y -- indented 4 spaces
        press return to exit block
- another function example
  * charAt :: String -> Int -> Char
    charAt str index = str !! index
- can see the type of a function in ghci with :t {function-name}
Are these predefined type classes?
- Data?
- Bits?, FiniteBits?
- Generic?
- Storable?
    </pre>

    <h4><a name="ClassConstraints">Class Constraints</a></h4>
    <div>
    </div>

    <h4><a name="TypeInference">Type Inference</a></h4>
    <div>
    </div>

    <h4><a name="TypeClasses">Type Classes</a></h4>
    <div>
      Type classes define a set of functions that must be implemented
      for types that are instances of the type class.
    </div>
    <pre>
- not like classes in OO languages
- define an interface (set of functions)
- names start uppercase
- types that are instances implement all the functions
  and are said to "derive" from the type class
- a type can derive from any number of type classes
- builtin examples include
    </pre>
    <!-- Include default implementations -->
    <div>
      The Prelude module defines the type classes
      described in the table below
      (duplicated in the Deriving section):
    </div>
    <table summary="Prelude type classes">
      <caption>Prelude Type Classes</caption>
      <tr>
        <th>Type Class Name</th>
        <th>Type Constructors</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>Bounded</td>
        <td></td>
        <td>
    - for types that have bounds
    - functions are minBound and maxBound
    - called on the type, not a value of the type
      * ex. maxBound :: Int
    - examples of builtin types that implement this are
      Char, Int, Float, and Double
        </td>
        <td></td>
      </tr>
      <tr>
        <td>Eq</td>
        <td></td>
        <td>
    - for types whose values can be compared for equality
    - functions are = and /=
    - all standard Haskell classes implement this
        </td>
        <td></td>
      </tr>
      <tr>
        <td>Ord/td>
        <td></td>
        <td>
    - for types whose values can be ordered
    - functions are <, <=, >=, and >
        </td>
        <td></td>
      </tr>
      <tr>
        <td>Ordering</td>
        <td>EQ, LT, and GT</td>
        <td>used by the <code>compare</code> function
          in the <code>Ord</code> type class</td>
        <td>compare 1 2 == LT</td>
      </tr>
      <tr>
        <td>Enum</td>
        <td></td>
        <td>
    - for types with values that can be enumerated
      and used in ranges to create Lists
    - functions are succ and pred
    - examples of builtin types that implement this are
      Int, Integer, Float, and Double
        </td>
        <td></td>
      </tr>
      <tr>
        <td>Read</td>
        <td></td>
        <td>
          parses a string to create a value
    - opposite of Show
      * a little like JavaScript's JSON.parse
    - only function is read
    - when desired type is not known from context, must specify
      * ex. read "3.14" raises an exception
      * ex. read "3.14" :: Float
      * ex. read "[1, 2, 3]" :: [Int]
      * ex. read "(\"foo\", 7, True)" :: (String, Int, Bool)
        </td>
        <td></td>
      </tr>
      <tr>
        <td>Show</td>
        <td></td>
        <td>
          creates a string representation of a value
    - only function is show
      * a little like JavaScript's JSON.stringify
    - ex. show 3.14
    - ex. show [1, 2, 3]
    - ex. show ("foo", 7, True)
        </td>
        <td></td>
      </tr>
    </table>

    <h4><a name="TypeAliases">Type Aliases</a></h4>
    <div>
    </div>

    <h4><a name="TypeInstances">Type Instances</a></h4>
    <div>
    </div>

    <h4><a name="TypeConstructors">Type Constructors</a></h4>
    <div>
    </div>
    <pre>
- parameterized type definitions that can be passed many types (polymorphic)
- pass types to a type constructor of a type class or a to create a new type
- pass values to a data constructor to create an instance of a type
Type Variables
- allow a parameter or return type to be more than one type
  * ex. the head function works on lists of *any* type
    - its signature is head :: [a] -> a
      where a represents any type
  * ex. myFn :: Num n => n -> n
    - n can be any type that derives from Num
    - the part after :: up to and including =>
      is called a "type constraint"
  * ex. myFn :: (Read r, Show s) => r -> s
    - a contrived example; maybe there's a better one
    - r can be any type that derives from Read and
      s can be any type that derives from Show
- all type classes and types start uppercase
  and all type variables start lowercase
  * typically type variable names are a single character
- similar to generics in other languages such as Java and Flow/TypeScript
- functions whose signatures use type variables
  are called "polymorphic functions"
    </pre>
    <pre>
ShapeCompare example:

data Shape =
  Circle {
    centerX :: Float,
    centerY :: Float,
    radius :: Float
  } |
  Rectangle {
    x1 :: Float,
    y1 :: Float,
    x2 :: Float,
    y2 :: Float
  }
area :: Shape -> Float
area (Circle _ _ radius) = pi * radius ^ 2
area (Rectangle x1 y1 x2 y2) = (abs (x1 - x2)) * (abs (y1 - y2))
circle = Circle 1 2 3
rectangle = Rectangle 2 2 6 5
area circle == 28.27
area rectangle == 12.0

-- function that computes the width of a shape
width :: Shape -> Float
-- Circle version
width (Circle _ _ radius) = radius * 2
-- Rectangle version
width (Rectangle x1 _ x2 _) = abs (x1 - x2)

-- function that computes the height of a circle
height :: Shape -> Float
-- Circle version
height (Circle _ _ radius) = radius * 2
-- Rectangle version
height (Rectangle _ y1 _ y2) = abs (y1 - y2)

-- custom type class
class ShapeCompare kind where
  isLarger :: kind -> kind -> Bool
  isWider :: kind -> kind -> Bool
  isTaller :: kind -> kind -> Bool

-- implementation of ShapeCompare for Shape type
-- Note that the name of the type class being implemented
-- is followed by the name of the type for which it is being implemented.
-- We could implement the same type class for many types.
instance ShapeCompare Shape where
  isLarger shape1 shape2 = area shape1 > area shape2
  isWider shape1 shape2 = width shape1 > width shape2
  isTaller shape1 shape2 = height shape1 > height shape2
-- isLarger circle rectangle == False
-- isWider circle rectangle == False
-- isTaller circle rectangle == True
    </pre>

    <h4><a name="AlgebraicDataTypes">Algebraic Data Types</a></h4>
    <!-- Include constructors with arguments -->
    <div>
    </div>

    <h4><a name="Deriving">Deriving</a></h4>
    <div>
      The <code>deriving</code> keyword specifies that a
      type derives from any of seven provided type classes.
      A comma-separated list of type classes surrounded by
      parentheses follows the <code>deriving</code> keyword.
      The parentheses can be omitted when
      only deriving from one type class.
      It automatically implements them for you.
      These type classes are described in the following table
      (duplicated in the Type Classes section):
    </div>
    <table>
      <tr>
        <th>Type Class Name</th>
        <th>Functions</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Eq</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>Ord</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>Enum</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>Read</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>Show</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>Bounded</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>Ix</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <div>
      It is possible to override the function definitions
      provided by Haskell.  For example:
    </div>
    <pre>
data Size = S | M | L -- cannot say "deriving Show" since overridden below
instance Show Size where
  show S = "small"
  show M = "medium"
  show L = "large"
show S == "small"
size = M
show size == "medium"</pre>

    <h3><a name="Operators">Operators</a></h3>

    <table summary="operators">
      <tr>
        <th>Symbol</th>
        <th>Meaning</th>
      </tr>
      <tr>
        <td>--</td>
        <td>start of comment line</td>
      </tr>
      <tr>
        <td><code>{-</code></td>
        <td>start of multi-line comment</td>
      </tr>
      <tr>
        <td><code>-}</code></td>
        <td>end of multi-line comment</td>
      </tr>
      <tr>
        <td><code>+</code></td>
        <td>add</td>
      </tr>
      <tr>
        <td><code>-</code></td>
        <td>subtract/negate</td>
      </tr>
      <tr>
        <td><code>*</code></td>
        <td>multiply</td>
      </tr>
      <tr>
        <td><code>/</code></td>
        <td>division and substitution (as in e{f/x})</td>
      </tr>
      <tr>
        <td><code>^</code></td>
        <td>Num exponentiation</td>
      </tr>
      <tr>
        <td><code>^^</code></td>
        <td>Fractional exponentiation</td>
      </tr>
      <tr>
        <td><code>**</code></td>
        <td>Float (and Double?) exponentiation (ex. 2 ** 3 == 8)</td>
      </tr>
      <tr>
        <td><code>&&</code></td>
        <td>and</td>
      </tr>
      <tr>
        <td><code>||</code></td>
        <td>or</td>
      </tr>
      <tr>
        <td><code><</code></td>
        <td>less than</td>
      </tr>
      <tr>
        <td><code><=</code></td>
        <td>less than or equal</td>
      </tr>
      <tr>
        <td><code>==</code></td>
        <td>equal operator</td>
      </tr>
      <tr>
        <td><code>/=</code></td>
        <td>not equal</td>
      </tr>
      <tr>
        <td><code>>=</code></td>
        <td>greater than or equal</td>
      </tr>
      <tr>
        <td><code>></code></td>
        <td>greater than</td>
      </tr>
      <tr>
        <td><code>\</code></td>
        <td>beginning of lambda function</td>
      </tr>
      <tr>
        <td><code>.</code></td>
        <td>function composition; name qualifier</td>
      </tr>
      <tr>
        <td><code>|</code></td>
        <td>guard and case specifier; list comprehension separator; data definition alternative (enum type)</td>
      </tr>
      <tr>
        <td><code>++</code></td>
        <td>list concatenation</td>
      </tr>
      <tr>
        <td><code>:</code></td>
        <td>cons (appends head)</td>
      </tr>
      <tr>
        <td><code>!!</code></td>
        <td>Indexing</td>
      </tr>
      <tr>
        <td><code>..</code></td>
        <td>range-specifier for lists</td>
      </tr>
      <tr>
        <td><code>\\</code></td>
        <td>list difference</td>
      </tr>
      <tr>
        <td><code><-</code></td>
        <td>list comprehension generator; single assignment in do</td>
      </tr>
      <tr>
        <td><code>;</code></td>
        <td>definition separator</td>
      </tr>
      <tr>
        <td><code>-></code></td>
        <td>function type-mapping; lambda definition; case separator</td>
      </tr>
      <tr>
        <td><code>=</code></td>
        <td>type or value naming</td>
      </tr>
      <tr>
        <td><code>::</code></td>
        <td>type specification (has type)</td>
      </tr>
      <tr>
        <td><code>=></code></td>
        <td>context inheritance from class</td>
      </tr>
      <tr>
        <td><code>()</code></td>
        <td>unit, the empty value in IO () type</td>
      </tr>
      <tr>
        <td><code>>></code></td>
        <td>then, monad sequencing</td>
      </tr>
      <tr>
        <td><code>>>=</code></td>
        <td>monad sequencing with value passing</td>
      </tr>
      <tr>
        <td><code>>@></code></td>
        <td>object composition for monads</td>
      </tr>
      <tr>
        <td><code>(..)</code></td>
        <td>export constructor (postfix)</td>
      </tr>
      <tr>
        <td><code>[</code> and <code>]</code></td>
        <td>list constructors using <code>,</code> as separator</td>
      </tr>
      <tr>
        <td><code>(</code> and <code>)</code></td>
        <td>tuple constructors using <code>,</code> as separator; using infix operator as prefix</td>
      </tr>
      <tr>
        <td><code>`</code></td>
        <td>surround prefix operator to use as infix</td>
      </tr>
      <tr>
        <td><code>'</code></td>
        <td>surround literal character</td>
      </tr>
      <tr>
        <td><code>"</code></td>
        <td>surround literal string</td>
      </tr>
      <tr>
        <td><code>_</code></td>
        <td>Wildcard in pattern matching</td>
      </tr>
      <tr>
        <td><code>~</code></td>
        <td>irrefutable pattern</td>
      </tr>
      <tr>
        <td><code>!</code></td>
        <td>force evaluation (strictness flag)</td>
      </tr>
      <tr>
        <td><code>@</code></td>
        <td>"Read As" in pattern matching</td>
      </tr>
      <tr>
        <td><code>$</code></td>
        <td>evaluates expression on right and passes result to function on left</td>
      </tr>
    </table>

    <h4><a name="OperatorBasics">Basics</a></h4>
    <div>
      What are viewed as operators in other programming languages
      are actually infix functions in Haskell.
      Parentheses can be used to control order of evaluation.
      The tables below summarize the provided
      functions for operation on primitive types
      like numbers and booleans.
    </div>

    <table class="operators">
      <caption>Number Functions</caption>
      <tr>
        <th>Name</th>
        <th>Operation</th>
        <th>Example</th>
      </tr>
      <tr><td class="center">div</td><td>integer division, discarding remainder</td><td>div 8 3 == 2</td></tr>
      <tr><td class="center">mod</td><td>modulo</td><td>mod 8 3 == 2</td></tr>
      <tr><td class="center">gcd</td><td>greatest common denominator</td><td>gcd 12 15 == 3</td></tr>
      <tr><td class="center">lcm</td><td>least common multiple</td><td>lcm 6 10 == 30</td></tr>
      <tr><td class="center">even</td><td>determines if a number is even</td><td>&nbsp;</td></tr>
      <tr><td class="center">odd</td><td>determines if a number is odd</td><td>&nbsp;</td></tr>
      <tr><td class="center">abs</td><td>returns the absolute value of a number</td><td>&nbsp;</td></tr>
    </table>

    <table class="operators">
      <caption>Logic Functions</caption>
      <tr>
        <th>Name</th>
        <th>Operation</th>
      </tr>
      <tr><td class="center">&&</td><td>and</td></tr>
      <tr><td class="center">||</td><td>or</td></tr>
      <tr><td class="center">not</td><td>not</td></tr>
    </table>

    <div>
      These comparison functions required their operands
      to be the same type.
    </div>
    <table class="operators">
      <caption>Comparison Functions</caption>
      <tr>
        <th>Name</th>
        <th>Operation</th>
      </tr>
      <tr><td class="center">==</td><td>equal</td></tr>
      <tr><td class="center">/=</td><td>not equal</td></tr>
      <tr><td class="center">&lt;</td><td>less than</td></tr>
      <tr><td class="center">&lt;=</td><td>less than or equal</td></tr>
      <tr><td class="center">&gt;</td><td>greater than</td></tr>
      <tr><td class="center">&gt;=</td><td>greater than or equal</td></tr>
    </table>

    <h4><a name="Precedence">Precedence</a></h4>
    <div>
    </div>
    <pre>
$ precedence operator
- means expression after it takes precedence over expression before it
- ex. abs (x1 - x2) == abs $ x1 - x2
- Most people don't like this at first.
  You may think that it adds new syntax for no real gain.
  You may think you'll always use parens instead.
  You will probably cave in a use it later.
- another example
  putStrLn ("Hello, " ++ name)
  is the same as
  putStrLn $ "Hello, " ++ name

. precedence operator
- evaluates expression on right and passes it to function left
- need a good example</pre>

    <h4><a name="Associativity">Associativity</a></h4>
    <div>
      See the infix, infixl, and infixr keywords.
    </div>

    <h3><a name="Variables">Variables</a></h3>
    <div>
      The ghci REPL supports assigning values to variables with
      <code><i>name</i> = <i>expression</i></code>.
      However, this is only supported in ghci.
      In normal Haskell code, the let and where keywords
      are used to assign value to variables and
      then use those variables in a expression.
    </div>
    <div>
      The syntax to set a variable to the value of an expression
      and specify its type is:<br>
      <code><i>name</i> = <i>expression</i> :: <i>type</i></code>
    </div>
    <div>
      For example, <code>n = 3 :: Int</code>.
    </div>
    <div>
      All data in Haskell is immutable, meaning it cannot be modified.
      This means that variables are really constants.
    </div>
    <div>
      Values can be assigned to multiple variables in a single assignment.
      This is similar to destructuring in JavaScript.
      The syntax is for doing this is:<br>
      <code>(<i>name1</i>, <i>name2</i>) = (<i>value1</i>, <i>value2</i>)</code>
    </div>
    <div>
      Is it correct to say that a variable is really a function
      that always returns the same value?
    </div>

    <h3><a name="Functions">Functions</a></h3>

    <h4><a name="FunctionBasics">Basics</a></h4>
    <pre>
- syntax to call
  * name arguments
  * arguments are separated by spaces
  * to use the result of another function as an argument
    surround the call with parens
    - ex. max (min 2 3) (min 5 4) == 4
- syntax to define
  * name parameters = expression
  * parameters are separated by spaces
  * if the name consists of letters, the function is prefix
    - if the function has two parameters,
      surround with backticks to use as infix
    - ex. 8 `div` 3 == 2
  * if the name consists of only symbols, the function is infix
    - if the function has two parameters,
      surround with parens to use as prefix
    - ex. (*) 2 3 == 6
    - to pass an infix function as an argument to another function
      surround with parens
      * can also use parens to create a curried version
        to pass to another function
        - ex. map (* 2) someList
- defaults to prefix
  - can you specify that a function is infix?
- name cannot begin with an uppercase letter
- most functions are prefix functions,
  but some are infix functions
- to call a prefix function,
  start with the name followed by arguments
  all separated by spaces (no parens)
- all functions return a value
- prefix functions are evaluated before infix functions,
  so parens are needed in succ (2 * 3) which returns 7
  * succ 2 * 3 returns 9
    </pre>
    <div>
      Pure functions are ...
      Impure functions ...
      Examples of side effects include I/O, error handling,
      and modifying global state.
    </div>
    <pre>
      Other functions provided by Prelude include:
      * $
      * $!
      * asTypeOf
      * const
      * error
      * errorWithoutStackTrace
      * flip
      * id
      * seq
      * undefined
      * until
    </pre>

    <h4><a name="Currying">Currying</a></h4>
    <div>
      Haskell functions automatically support currying.
      If a function is called with fewer arguments than allowed,
      a new function is returned that accepts the remaining arguments.
      For example,
    </div>
    <pre>
add :: Int -> Int -> Int
add x y = x + y
plus5 = add 5
plus5 2 == 7

volume :: Num n => n -> n -> n -> n
volume w h d = w * h * d

v2 :: Num n => n -> n -> n
v2 = volume 2

v3 :: Num n => n -> n
v3 = volume 2 3

volume 2 3 4 == 24
v2 4 == 24
v3 3 4 == 24</pre>

    <h4><a name="Recursion">Recursion</a></h4>
    <div>
      A recursive function is a function calls itself,
      either directory or in another function that it calls.
    </div>
    <pre>
- factorial with pattern matching and recursion
  fac :: Int -> Int
  fac 0 = 1
  fac n = n * fac (n - 1)
  fac 4 -- 24
- factorial without recursion
  fac2 :: Int -> Int
  fac2 n = product [1..n]
    </pre>

    <h4><a name="FunctionComposition">Function Composition</a></h4>
    <div>
      The "dot" operator composes two single-argument functions.
      This character was chosen because it is the closest
      easily typeable character to &#x25cb; which is the symbol
      used for function composition in mathematics.
      It creates a new function that
      calls the right function with its argument and
      then calls the left function with that result.
      For example:
    </div>
    <pre>
(f . g) x === f (g x)
(f . g . h) x === f (g (h x))
// When x is 2, 2 * ((4 * x) + 3) is 22
// This can also be written as
((* 2) . (+ 3) . (* 4)) 2 === 22
    </pre>
    <pre>
      h p1 p2 = f (g p1 p2)
      h p1 p2 = f $ g p1 p2
      h p1 p2 = (f . g) p1 p2
      h = f . g -- point-free form
    </pre>
    <div>
      A downside of the point-free form is that removing the parameters
      removes any description of their meaning.
    </div>

    <h4><a name="ArgumentCapture">ArgumentCapture</a></h4>
    <div>
    </div>

    <h4><a name="PatternMatching">Pattern Matching</a></h4>
    <pre>
- creates overloaded versions of a function
  based on specific argument values
- evaluated in the order defined
- ex.
  place :: Int => String
  place 0 = "not started"
  place 1 = "first"
  place 2 = "second"
  place 3 = "third"
  place n = show n ++ "th" -- catchall pattern
  * TODO: Handle 11, 12, 13, 21, 22, 23, ...
- ex.
  quadrant :: (Num n, String s) => n -> n -> s
  quadrant 0 y = "on y-axis"
  quadrant x 0 = "on x-axis"
  quadrant x y = -- preferable to use guards (see below)
    if x > 0 && y > 0 then "first"
    else if x < 0 && y > 0 then "second"
    else if x < 0 && y < 0 then "third"
    else if x > 0 && y < 0 then "fourth"
    else "impossible"
- non-exhaustive pattern matching
  * will get exception "Non-exhaustive patterns in function greek" from greek 3
  greek :: Int -> String
  greek 1 = "alpha"
  greek 2 = "beta"
- with tuples
  - ex.
  tupleMult :: Int -> (Int, Int) -> (Int, Int)
  tupleMult n (a, b) = (a * n, b * n)
  tupleMult 2 (3, 4) == (6, 8)
  * ex.
  tupleLast :: (Int, Int, Int) -> Int
  tupleLast (_, _, last) = last
  tupleLast (5, 2, 7) == 7
- with lists
  * note use of parens instead of []
  * ex.
  listSumFirst3 :: [Int] -> Int
  listSumFirst3 (i1:i2:i3:rest) = i1 + i2 + i3
  listSumFirst3 [1,2,3,4,5] == 6
  * ex.
  addHead :: [Int] -> [Int]
  addHead (x:xs) = map (+ x) xs
  addHead [2, 3, 4, 5] == [5, 6, 7]
  - the use of variable names x and xs are common to get
    the first item and the rest of the items in a list
    </pre>

    <h4><a name="Guards">Guards</a></h4>
    <pre>
- can use both pattern matching and guards for same function,
  but often it is best to use one or the other
- improved vesion of quadrant
  quadrant x y -- with guards
    | x == 0 = "on y axis"
    | y == 0 = "on x axis"
    | x > 0 && y > 0 = "first"
    | x < 0 && y > 0 = "second"
    | x < 0 && y < 0 = "third"
    | x > 0 && y < 0 = "fourth"
    | otherwise = "impossible"
- ex.
  colorMeaning :: String -> String
  colorMeaning color
    | color == "red" = "fire"
    | color == "green" = "land"
    | color == "blue" = "water"
    | otherwise = "no meaning"
- a where clause computes values used in guards
  * ex.
    grade :: Int -> Int -> Char
    grade points possible
      | percent >= 90 = 'A'
      | percent >= 80 = 'B'
      | percent >= 70 = 'C'
      | percent >= 60 = 'D'
      | otherwise = 'F'
      where percent = (fromIntegral points) / (fromIntegral possible) * 100
- using both guards and pattern matching
  runLengthEncode :: Eq a => [a] -> [a]
  runLengthEncode (x1:x2:xs) -- for lists of length 2 or more
    | x1 == x2 = runLengthEncode (x2 : xs)
    | otherwise = x1 : runLengthEncode (x2 : xs)
  runLengthEncode xs = xs -- for lists of length 1 or 0
    </pre>

    <h4><a name="LambdaFunctions">Lambda Functions</a></h4>
    <div>
      Lambda functions are functions that do not have name,
      also known as anonymous functions.
      They are often used to pass short functions to another function
      such as <code>map</code>.
      For example, the following lambda is used to
      double and add one to each number in a list.
    </div>
    <pre>
map (\x -> x * 2 + 1) [1,2,3] = [3,5,7]</pre>
    <div>
      The character <code>\</code> was selected
      to denote the beginning of a lambda
      because it is part of the character lambda.
    </div>

    <h4><a name="HigherOrderFunctions">Higher Order Functions</a></h4>
    <div>
      Higher order functions are functions that take another function as an argument or return a function.
      An example is the <code>map</code> function
      which takes a function and a list and
      returns a new list which is the result of
      calling the function on each element of the list.
    </div>
    <pre>
- these are functions that take an argument that is a function
- map returns a list contructed from the results
  of passing each item in a list to a function
  * ex. map succ [1,3,7] == [2,4,8]
- filter
  * takes a function and list and returns a list of
    the items for which the function returns True
  * ex. filter odd [1,4,7,10] == [1,7]
  * ex. filter (> 5) [1,4,7,10] == [7, 10]
    - (> 5) creates a function using currying
- foldl is like reduce in JavaScript
  * takes a function, starting value, and a list
    - if the function is an infix function,
      surround it with parens to turn it into a prefix function
  * ex. foldl (*) 1 [1,2,3,4] == 24
    - of course this can be done more easily with product [1,2,3,4]
- foldr is like foldl, but processes
  the list items from right to left
- ex.
  double :: Int -> Int
  double x = x * 2
  -- first parameter type is a function that takes an Int and returns an Int
  process :: (Int -> Int) -> Int -> Int
  process fn n = fn (n + 1)
  -- process double 2 == 6 which is (2 + 1) * 2
    </pre>

    <h3><a name="DataStructures">Data Structures</a></h3>
    <div>
      Basic data structures are provided
      by the <code>Prelude</code> module.
      Additional data structures are provided
      by the <code>Data</code> module.
    </div>

    <h3><a name="Lists">Lists</a></h3>

    <h4><a name="ListBasics">Basics</a></h4>
    <div>
      Lists are collections of items that have the same type.
      Literal lists can be specified by enclosing a
      comma-separated list of items in square brackets.
    </div>
    <div>
      When creating a new list that contains all the
      items in an existing list plus a new item,
      it is more efficient to add it to the beginning than the end.
      So <code>item : list</code> is
      more efficient than <code>list ++ [item]</code>.
      Of course sometimes the order of items in the new list
      matters and adding to the front isn't an option.
    </div>
    <pre>
- ex. [1, 3, 7]
  * same as 1 : 3 : 7 : []
  * : is called the "cons" operator
- implemented as linked lists, so
  accessing items other than the first is not efficient
- to get number of items, length list
- to test whether a list is empty, null list
  * returns a boolean
- slicing
  * these raise an exception if called on an empty list
  * to get first item, head list
  * to get last item, last list
  * to get all but first item, tail list
  * to get all but last item, init list
- to create a list that contains the first n items, take n list
- to create a list that contains the last n items, drop n list
- to create list that is result of prepending new item
  * item : list
- to create list that is result of appending new item
  * list ++ [item]
- to create list where first item is modified
  * newItem : tail list
- to create a new list by concatenating two lists
  * list1 ++ list2
  * both arguments must be a list
- to get an item at a given index
  * list !! index
  * indexes start at 1
  * also used to get a character from a string since those are lists
  * slow for long lists since implemented with a linked list
- to create a reversed copy of a list: reverse list
- to get smallest number in a list: minimum list
- to get largest number in a list: maximum list
- to get sum of numbers in a list: sum list
- to get product of numbers in a list: product list
- to test whether an item is in a list: elem item list
- lists can be nested
- lists can be compared if corresponding items can be compared
  * ex. [1, 3, 5] < [2, 4, 6] gives True
  * ex. [1, 3, 5] < [1, 4, 6] gives True
  * ex. [1, 3, 5] < [1, 3, 6] gives True
  * ex. [1, 3, 5] < [1, 3, 5] gives False
- other list functions
  * notElem
  * concat takes a list of list and returns a flatten list
    - the lists cannot contain nested lists
      * recall that all items in a list must be the same type,
        so [1, [2, 3]] is not a valid list
    - ex. concat [[1,2], [3,4,5]] == [1,2,3,4,5]
  * takeWhile creates a list of all initial items
    in another list that meet a predicate
    - ex. takeWhile even [2,4,6,7,8] == [2,4,6]
  * dropWhile creates a list of all remaining items
    in another list after the initial elements meet a predicat
    - ex. dropWhile even [2,4,6,7,8] == [7,8]
  * words takes a string and returns a list of words delimited by spaces
    - ex. words "foo bar baz" == ["foo","bar","baz"]
  * unwords takes a list of works and returns a string of the words separated by spaces
    - ex. unwords ["foo","bar","baz"] == "foo bar baz"
  * splitAt creates a list of two lists obtained by
    spliting a given list at an index
    - ex. splitAt 3 [1,2,3,4,5] == [[1,2,3], [4,5]]
  * sort creates a sorted version of a list
    - must import Data.List
    - ex. sort [9, 3, 6, 2] == [2, 3, 6, 9]
  * zipWith creates a list from multiple lists using the result
    of a function called with items at corresponding positions
    - ex. zipWith min [1, 9, 5, 4] [2, 7, 6] === [1, 7, 5, 4]
    - note how the last item in the first list has no corresponding item
      in the second, so it just used that item in the result
    </pre>

    <table summary="List functions">
      <caption>List Functions</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>!!</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>++</td>
        <td>builds a new list that is the concatenation of two lists</td>
        <td></td>
      </tr>
      <tr>
        <td>filter</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>head</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>init</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>last</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>length</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>map</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>null</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>reverse</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>tail</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions that build finite lists">
      <caption>Functions That Build Finite Lists</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>replicate</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>scanl</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>scanl1</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>scanr</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>scanr1</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions that build infinite lists">
      <caption>Functions That Build Infinite Lists</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>cycle</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>iterate</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>repeat</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions that extract part of a list">
      <caption>Functions That Extract Part of a List</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>take</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>takeWhile</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>drop</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>dropWhile</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>splitAt</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions that search a list">
      <caption>Functions That Search a List</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>lookup</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>notElem</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions that zip and unzip lists">
      <caption>Functions That Zip and Unzip Lists</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>zip</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>zipWith</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>zipWith3</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>unzip</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>unzip3</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions that convert between strings and lists">
      <caption>Functions That Convert Between Strings and Lists</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>lines</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>words</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>unlines</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>unwords</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table summary="functions in Data.List">
      <caption>Functions in Data.List</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>isInfixOf</td>
        <td>determines whether a list is contained anywhere within another</td>
        <td>isInfixOf "bc" "abcd" == True</td>
      </tr>
      <tr>
        <td>isPrefixOf</td>
        <td>determines whether a list appears at the beginning of another</td>
        <td>isPrefixOf "ab" "abcd" == True</td>
      </tr>
      <tr>
        <td>isSuffixOf</td>
        <td>determines whether a list appears at the end of another</td>
        <td>isInfixOf "cd" "abcd" == True</td>
      </tr>
    </table>

    <div>
      Functions can use pattern matching to match on lists.
      For example:
    </div>
    <pre>
- can use a kind of destructuring to get items from a list parameter
  * ex.
    -- This takes a list of Ints and returns a String.
    listReport :: [Int] -> String
    -- only matches empty lists
    listReport [] = "empty"
    -- only matches lists with one item
    listReport (first:[]) = "first is " ++ show first
    -- only matches lists with two items
    listReport (first:second:[]) =
      "initial are " ++ show first ++ " and " ++ show second
    -- only matches lists with more than two items
    listReport (first:rest) = show first ++ " and " ++ show rest
- can get full list and some items
  * ex.
    initial :: String -> String
    -- first is a Char; [first] is a list of Chars which is a String
    initial name@(first:rest) = name ++ " starts with " ++ [first]
- can build a new list by processing each item in a list recursively
  * ex.
    doubleList :: [Int] -> [Int]
    doubleList [] = []
    doubleList (first:rest) = first * 2 : doubleList rest
    -- Note use of cons operator (:) above.
  * can also do this with
    map (* 2) [1,2,3]
    </pre>

    <h4><a name="ListComprehension">List Comprehension</a></h4>
    <pre>
- like a list factory
- produces a list containing the results of an expression
  where a variable is set to each value in another list
- ex. [n * 2 | n <- [1..4]] == [2,4,6,8]
  * n * 2 is called the "output"
  * [1..4] is the list from which values are "drawn"
  * each item drawn is bound to n
- a "predicate" can be added after the draw list
  to filter the items drawn
  * ex. [n * 2 | n <- [1..4], even n] == [4,8]
  * can have any number of predicates separated by commas
- can draw values from more than one list
  * ex. [a + b | a <- [1,2,3], b <- [4,5]] == [5,6,6,7,7,8]
  * uses the cartesian product of the lists
  * goes through all items in second list for each item in first list
    - order is 1 and 4, 1 and 5, 2 and 4, 2 and 5, 3 and 4, 3 and 5
  * can split onto multiple lines, but not in the REPL
    - ex.
      [n * 2 |
       n <- [1..4],
       even n]
- ex. remove all spaces, dashes, and underscores from a string
  * squeeze str = [char | char <- str, not (elem char [' ', '-', '_'])]
  * squeeze "foo bar-baz_qux" == "foobarbazqux"
    </pre>

    <h4><a name="Ranges">Ranges</a></h4>
    <pre>
- create lists of all elements between two items inclusive
  * ex. [3..7] == [3,4,5,6,7]
  * ex. ['c'..'f'] == "cdef"
- can specify a step by including second item
  * ex. [5, 10..27] == [5,10,15,20,25]
- specifying a step is the only way to get a decreasing range
  * ex. [10, 9..0] == [10,9,8,7,6,5,4,3,2,1,0]
- to create an infinite list, don't specify upper bound
  * ex. [3, 6..]
  * in the REPL this will output items forever (ctrl-c to stop)
  * use a function like take to limit the output
    - ex. take 10 [3, 6..]
- replicate creates a list containing a given number of the same item
  * ex. replicate 3 "Ho" == ["Ho","Ho","Ho"]
  - note how this creates a list of strings rather than an single string
- repeat creates an infinite list of a single repeated item
  * ex. take 4 (repeat 3) === [3,3,3,3]
- cycle creates an infinite list of repeating items
  * ex. take 6 (cycle [5, 10]) === [5,10,5,10,5,10]
    </pre>

    <h4><a name="AssociationLists">Association Lists</a></h4>
    <div>
      Association lists are lists of pairs (two-element tuples)
      that are used like hashmaps.
      Using these for large numbers of key/value pairs
      is much less efficient that using a <a href="#Map">Map</a>,
      but is probably fine for small numbers.
    </div>
    <pre>
- ex. mapping = [("foo", 1), ("bar", 2)]
- lookup function finds the value for a given key
  * ex. lookup "bar" mapping == Just 2
  * ex. lookup "baz" mapping == Nothing
  * just does a sequential search, so not efficient
    </pre>

    <h3><a name="Tuples">Tuples</a></h3>
    <div>
      A tuple is a fixed length set of values
      with specific types at each position.
      Each position can hold a different type.
      A tuple is called a "pair" if it holds two items.
      This is the most common size.
      A tuple is called a "triple" if it holds three items.
      The maximum length of a tuple is 62.
    </div>
    <div>
      Items in a tuple are surrounded by parentheses
      instead of square brackets like in lists.
    </div>
    <pre>
- in functions that take a tuple as an argument, can destructure
  * ex. addTuples (a1, a2) (b1, b2) = (a1 + b1, a2 + b2)
    addTuples (3, 4) (7, 9) == (10, 13)
- zip creates a list of tuples from two lists
  * ex. zip [1, 2, 3] [4, 5] === [(1,4),(2,5)]
  * number of tuples in result is equal to length of shortest list
- unzip creates a tuple of lists from a list of tuples
  * ex. unzip [(1,4), (2,5)] == ([1,2], [4,5])
    </pre>

    <table summary="Tuple functions">
      <caption>Tuple Functions</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>fst</td>
        <td>returns the first element of a pair (only works on pairs)</td>
        <td>fst ("foo", "bar") == "foo"</td>
      </tr>
      <tr>
        <td>snd</td>
        <td>returns the second element of a pair (only works on pairs)</td>
        <td>snd ("foo", "bar") == "bar"</td>
      </tr>
      <tr>
        <td>curry</td>
        <td></td>
        <td>converts an uncurried function to a curried one</td>
      </tr>
      <tr>
        <td>uncurry</td>
        <td></td>
        <td>converts a curried function to an uncurried one</td>
      </tr>
    </table>

    <h3><a name="Records">Records</a></h3>

    <h4><a name="RecordBasics">Basics</a></h4>
    <div>
      Records are often used for describing model types.
      For example, a model for a todo might look like the following:
    </div>
    <pre>
data ToDo = ToDo {
  id :: Text, -- Haskell can automatically convert between Text and String
  description :: Text
} deriving (Generic, Show)

-- used by aeson to generate a JSON representation of a ToDo
instance ToJson ToDo
-- used by aeson to parse a JSON representation of a ToDo
instance FromJson ToDo
    </pre>
    <pre>
-- Custom, struct-like data type.
-- Why can't a field use the name "id"?
-- It seems to conflict with Prelude.id.
data Person = Person
  { personId :: Int
  , firstName :: String
  , middleName :: String
  , lastName :: String
  --, birthday :: Date
  } deriving (Show)

Creating an instance in the following way
requires a value for ALL fields!
p1 = Person 19 "Richard" "Mark" "Volkmann" "April 16"

Can only some of the fields be specified with this syntax?
p2 =
  Person
  { firstName = "Richard"
  , middleName = "Mark"
  , lastName = "Volkmann"
  }

Can use field names as accessor functions with "{field-name} p".
This is an issue if a field name is a Haskell keyword
or if other records have a field with the same name!
Will get an error if the field has no value.

Can get a string representation with "show p".

Here is a function that operates on a Person.
initials :: Person -> String
initials p = head (firstName p) : head (middleName p) : head (lastName p) : []

The following creates a new Person that is
 a modified version of an existing one.
p3 = p2 {firstName = "Tamara", middleName = "Ann"}
    </pre>

    <h4><a name="RecordUpdating">Updating</a></h4>
    <div>
    </div>

    <h3><a name="Arrays">Arrays</a></h3>
    <div>
      See Data.Array.
    </div>

    <h3><a name="Maps">Maps</a></h3>
    <pre>
- a hashmap data structure
- can create from an association list
- to use, without Data.Map prefix, import qualified Data.Map as M
  * Do you have to add "containers" as a dependency to use this?
- When a parameter or return type is a Map,
  the types of the keys and values must be specified.
  For example, M.Map String Int
- To create an empty map, use <code>M.empty</code>.
- ex. myMap = fromList [("foo", 1), ("bar", 2)]
- to get the value for a given key, myMap ! key
- to get the number of keys in a Map, size myMap
- see map-demo.hs
    </pre>

    <h4><a name=""></a></h4>
    <div>
    </div>

    <h3><a name="Modules">Modules</a></h3>
    <pre>
- typically define functions that are useful in other code
- module names must start with an uppercase letter
- Haskell Standard Library
  * modules that ship with a Haskell compiler
  * https://downloads.haskell.org/~ghc/latest/docs/html/libraries/
  * top-level module names are:
    Compiler, Control, Data, Debug, Distribution, Foreign,
    GHC, GHCi, Graphics, Language, Media, Numeric, Prelude,
    SizedSeq, System, Text, Trace, Type, Unsafe, Utils
    - for async I/O, see Control.Concurrent.Async
      * in standard library or separate download?
- can use functions in any module by prefixing them with the module name
  * ex. Data.List, Data.Map, System.IO
- to use functions in a module
  * without prefixes, import {ModuleName}
    - ex. import Data.Text
    - some names in an imported module might conflict with
      those in Prelude, those in other imported modules, or your own functions,
      so doing this is not recommended
  * with full name, import qualified {ModuleName}
    - ex. import qualified Data.Text
    - use Data.Text. as prefix on all names in this module
  * with a specified prefix, import qualified {ModuleName} as {prefix}
    - ex. import qualified Data.Text as T
    - use T. as prefix on all names in this module
    - ex. import qualified Data.Map as M
    - use M. as prefix on all names in this module
- the most commonly used functions are defined in the Prelude module
  * "imported by default into all Haskell modules unless
    either there is an explicit import statement for it,
    or the NoImplicitPrelude extension is enabled"
- to define a module
  * create a file named {module-name}.hs
  * first line must be
    module {module-name} where
  * add definitions after this
    </pre>

    <h4><a name="Importing">Importing</a></h4>
    <div>
    </div>

    <h4><a name="QualifiedImports">Qualified Imports</a></h4>
    <div>
    </div>

    <h4><a name="Exclusions">Exclusions</a></h4>
    <div>
    </div>

    <h4><a name="Exporting">Exporting</a></h4>
    <div>
      A module can explicitly export a subset of its top-level declarations
      by listing the names to be exported in parentheses
      after the module name and before the <code>where</code> keyword.
      If this list is omitted, all top-level declarations are exported.
    </div>

    <h3><a name="Syntax">Syntax</a></h3>
    <div>
      The mostly commonly used parts of Haskell syntax include
      if/then/else, case/of, let/in, where, do, ...
    </div>

    <h4><a name="EvaluationOrder">Evaluation Order</a></h4>
    <div>
      Typically expressions are evaluated from left to right.
      This can be modified by using parentheses like in many other programming languages.
      In addition, the <code>$</code> operator can be used.
      This causes the expression to the right to be evaluated first
      and then used as an argument to the function on the left.
    </div>
    <div>
      The following are equivalent:
    </div>
    <pre>
      let result = a * (b + c)
      let result = (*) a $ b + c
      let result = (a *) $ b + c
      let result = (* a) $ b + c
    </pre>
    <div>
      Perhaps <code>$</code> was chosen as the character for this operator
      because it also represents the end in regular expressions.
    </div>
    <div>
      Pretty much all developers understand using parentheses
      to modify the order of evaluation.  Using the <code>$</code> operator
      seems to have minimal benefit at the risk of adding confustion.
    </div>

    <h4><a name="Comments">Comments</a></h4>
    <div>
      Single-line comments in Haskell start with <code>--</code>
      and continue to the end of the line.
      Multi-line comments are surrounded with
      <code>{-</code> and <code>-}</code>.
    </div>


    <h4><a name="StringsAndCharacters">Strings &amp; Character</a></h4>
    <div>
      The <code>String</code> type in Haskell
      is an alias for the type <code>[Char]</code>.
      This means that list functions can be used on strings.
    </div>
    <table>
      <caption>Char Functions (<code>import Data.Char</code>)</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>toUpper</td>
        <td>returns the uppercase version of a Char</td>
        <td>toUpper 'g' == 'G'</td>
      </tr>
      <tr>
        <td>toLower</td>
        <td>returns the lowercase version of a Char</td>
        <td>toLower 'G' == 'g'</td>
      </tr>
      <tr>
        <td>other?</td>
        <td></td>
        <td></td>
      </tr>
    </table>
    <table>
      <caption>String Functions</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>++</td>
        <td>concatenates (building a new list from two lists)</td>
        <td>"foo" ++ "bar" == "foobar"</td>
      </tr>
      <tr>
        <td>show</td>
        <td>converts a value of any type that derives Show to a String</td>
        <td>show 19 == "19"</td>
      </tr>
      <tr>
        <td>map toUpper</td>
        <td>returns the uppercase version of a String</td>
        <td>map toUpper "abc" == "ABC"</td>
      </tr>
      <tr>
        <td>map toLower</td>
        <td>returns the lowercase version of a String</td>
        <td>map toLower "ABC" == "abc"</td>
      </tr>
    </table>
    <div>
      Another way to change the case of a String is:
    </div>
    <pre>
      things to convert values to a string
      * ShowS type
      * Show type class
      * shows, showChar, showString, and showParen functions
      things to convert strings to a value
      * ReadS type
      * Read type class
      * reads, readParen, read, and lex functions
    </pre>
    <pre>
import qualified Data.Text as T
p = T.pack "foo"
T.toUpper p</pre>
    <div>
      Why would this approach every be preferred?
    </div>
    <pre>
- ex.
  import Data.Char
  capitalize :: String -> String
  capitalize (x:xs) = toUpper x : map toLower xs
  -- words breaks a sentence into a list of words by splitting on spaces.
  -- map capitalize runs on that list and returns a list of capitalized words.
  -- unwords concatenates all the Strings in list into a single String,
  -- adding a space between each.
  titleCase = unwords . map capitalize . words
  title = titleCase "pEE wee'S Big adventure"
    </pre>

    <h4><a name="Numbers">Numbers</a></h4>
    <div>
      This was already covered in the "Prelude Types" section.
    </div>
    <table summary="Number functions">
      <caption>Number Functions</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>div</td>
        <td>returns integer division result</td>
      </tr>
      <tr>
        <td>max</td>
        <td>returns largest of two arguments</td>
      </tr>
      <tr>
        <td>min</td>
        <td>returns smallest of two arguments</td>
      </tr>
      <tr>
        <td>pred</td>
        <td>returns predecessor of a number</td>
        <td>pred 3 === 2</td>
      </tr>
      <tr>
        <td>succ</td>
        <td>returns successor of a number</td>
        <td>succ 3 === 4</td>
      </tr>
      <tr>
        <td>pi</td>
        <td>value of the constant pi</td>
      </tr>
      <tr>
        <td>round</td>
        <td>rounds to closest integer</td>
      </tr>
      <tr>
        <td>ceiling</td>
        <td>rounds up</td>
      </tr>
      <tr>
        <td>floor</td>
        <td>rounds down</td>
      </tr>
      <tr>
        <td>truncate</td>
        <td>rounds toward zero</td>
      </tr>
      <tr>
        <td>sqrt/td>
        <td>square root</td>
      </tr>
      <tr>
        <td>trigononetry</td>
        <td>sin, cos, tan, asin, acos, and atan</td>
      </tr>
      <tr>
        <td>hyperbolic trigonometry</td>
        <td>sinh, cosh, tanh, asinh, acosh, and atanh</td>
      </tr>
      <tr>
        <td>logarithmic</td>
        <td>log (base e) and exp (e ** n)</td>
      </tr>
      <tr>
        <td>hypot</td>
        <td>length of triangl hypoteneuse</td>
        <td>
hypot x y = sqrt (x * x + y * y)
hypot 3 4 returns 5
        </td>
      </tr>
    </table>
    <div>
      Most functions that take two or more numbers
      require them to be the same type.
      For example,
    </div>
    <pre>
a = 3
b = 2.1
a + b -- okay, 5.1
a = 3 :: Int
b = 2.1 :: Float
a + b -- error</pre>
    <div>
      To convert an <code>Integral</code> to a <code>Floating</code>,
      <code>fromIntegral <i>integralValue</i></code>.
    </div>
    <div>
      Say more about type conversions.
    </div>

    <h4><a name="DatesAndTimes">Dates and Times</a></h4>
    <pre>
- see https://two-wrongs.com/haskell-time-library-tutorial
- import Data.Time
- to create a Day instance, use fromGregorian[Valid] year month day
  * year must Integer; month and year must be Int
  * returns Day
  * without Valid
    - returns a Day where the month is 1 if given < 1
      and the day is the last day in the month if given > last day
  * with Valid
    - returns a Maybe that is
      a Maybe Day if it's a valid date
      and Nothing if it isn't a valid date
- to get a triple (year, month, day) from a Day,
  ymd = toGregorian someDay
- to get a String representation of a Day,
  show someDay
- to create a Day that is n days after someDay,
  newDay = addDays n someDay
  * n can be negative to subtract days
- to create a Day that is n months after someDay,
  newDay = addGregorianMonthsClip n someDay
  * n can be negative to subtract months
  * "Clip" means that it will adjust the day to be within the result month
- to get the number of days between to Day instances,
  diff = diffDays day1 day2
- to get the current date and time,
  now <- getCurrentTime -- type is IO UTCTime
  * getCurrentTime is impure
    (can return a different value each time it is called)
  * to get the UTCTime value out of it, use <- instead of =
- to create a new UTCTime that is n seconds after someTime,
  newTime = addUTCTime n someTime
- to get the number of seconds between two UTCTime instances,
  diff = diffUTCTime time1 time2
    </pre>

    <h4><a name="Enumerations">Enumerations</a></h4>
    <div>
      Enumerated types are types with a fixed list of values.
      They are also referred to as algebraic data types.
    </div>
    <pre>
- ex. creating a custom Color type
  data Color = Red | Green | Blue deriving (Eq, Ord, Show, Read)
  * Red, Green, and Blue are "value constructors"
    - used to create an instance of Color
    - they can take arguments as shown below
    - they can be used in pattern matching
  * deriving causes the compiler to implement the
    functions in a type class for your type for you
    - don't need if you're going to supply the implementation
  * deriving from Eq allows Cocalor values to be compared with == and /=
  * deriving from Ord allows Color values to be compared with <, <=, >=, >
  * deriving from Show allows Color values to be converted to Strings
  * deriving from Read allows strings to be Color values
    - ex. read "Red" :: Color
- using the custom Color type
  colorToTemp2 :: Color -> String
  colorToTemp2 color = case color of
    Red -> "hot"
    Blue -> "cold"
    _ -> "normal"
    </pre>

    <!-- include deconstruction -->
    <h4><a name="IfThenElse">IfThenElse</a></h4>
    <div>
      The <code>if</code> keyword begins an expression whose value
      is either the <code>then</code> or <code>else</code> expression
      depending on a condition.
      The condition is not surrounded by parentheses
      like in many other languages.
      The <code>else</code> keyword is required
      because some value must be produced.
    </div>
    <div>
      The syntax is:
    </div>
    <pre>
if <i>condition</i> then <i>expression</i> else <i>expression</i></pre>
    <div>
      Give some examples!
    </div>

    <h4><a name="Case">Case</a></h4>
    <pre>
  * case variable of
      v1 -> r1
      v2 -> r2
      _ -> r3
  * ex.
    tempToColor :: String -> String
    tempToColor temp = case temp of
      "hot" -> "red"
      "cold" -> "blue"
      _ -> "green"
    </pre>

    <h4><a name="Let">Let</a></h4>
    <div>
      The <code>let</code> keyword allows multiple assignments to names
      that are then used to evaluate an expression
      that follows the <code>in</code> keyword.  For example:
    </div>
    <pre>
sumOfSquares :: Num a => a -> a -> a
sumOfSquares x y =
  let xSquared = x * x
      ySquared = y * y
  in xSquared + ySquared</pre>

    <h4><a name="Where">Where</a></h4>
    <div>
      The <code>where</code> keyword is similar to the <code>let</code> keyword.
      One differences is that the expression to be evaluated precedes
      the assignments to names.
      Another difference is that <code>let</code> is an expression
      whereas <code>where</code> is not.
      In most cases, <code>let</code> is preferred over <code>where</code>.
      For example:
    </div>
    <pre>
sumOfSquares :: Num a => a -> a -> a
sumOfSquares x y = xSquared + ySquared
  where
    xSquared = x * x
    ySquared = y * y</pre>

    <h4><a name="Do">Do</a></h4>
    <div>
      The do keyword is typically used in conjunction with monads,
      but it can also be used just to have a block of expressions
      where the value of the do is the value of the last expression.
      However, do is typically only used when there is at least
      one expression that evaluates to a monad.
      For example:
    </div>
    <pre>
sumOfSquares :: Num a => a -> a -> a
sumOfSquares x y = do
  let xSquared = x * x
  let ySquared = y * y
  xSquared + ySquared</pre>

    <h3><a name="InputOutput">Input/Output</a></h3>
    <div>
      In Haskell, input and output are considered to be side effects.
      All side effects must take place in a monad.
      The IO monad does this.
      When an IO monad is "evaluated", it produces output.
      Functions like putStrLn have a return type of IO ().
      The () at the end means that evaluating the monad doesn't return anything.
    </div>
    <pre>
      input/output with stdin and stdout
      * IO monad
      * output functions putChar, putStr, putStrLn, and print
      * input functions getChar, getLine, getContents, and interact
      input/output with files
      * FilePath type
      * readfile, writeFile, appendFile, readIO, and readLn functions
      exception handling
      * IOError type
      * ioError and userError functions

- to print a line to stdout
  * putStrLn someString
  * print someValue
    - same as putStrLn, but calls show on its argument
      to get string represenation of someValue
      print = putStrLn . show
- simple example
main :: IO ()
main = do
  putStrLn "Enter your name:"
  name <- getLine
  putStrLn ("Hello, " ++ name ++ "!")

- moving prompt and getLine to a function
getName :: IO String
getName = do
  putStrLn "Enter your name:"
  getLine -- returns an IO monad wrapping a string
main :: IO ()
main = do
  name <- getName
  putStrLn ("Hello, " ++ name ++ "!")

- moving all to a function
getName :: IO ()
getName = do
  putStrLn "Enter your name:"
  name <- getName
  putStrLn ("Hello, " ++ name ++ "!") -- returns an IO monad wrapping nothing
main :: IO ()
main = getName

File I/O
- import System.IO
- to write from a file
  filePath = "demo.txt"
  writeDemo = do
    file <- openFile filePath WriteMode
    hPutStrLn file ("some text")
    hClose file
  writeDemo
- to read from a file
  readDemo = do
    file <- openFile filePath ReadMode
    contents <- hGetContents file
    putStr contents
    hClose file
  readDemo
- to read from a file and write its contents
  to a new file where all text is uppercase
import Data.Char -- for toUpper
import System.IO ()
main :: IO ()
main = do
  contents <- readFile "in.txt"
  let transformed = map toUpper contents
  writeFile "out.txt" transformed

Are there any libraries that provide support for asynchronous I/O
like in Node?
    </pre>

    <h4><a name="DoBlocks">Do Blocks</a></h4>
    <div>
      A <code>do</code> block executes a series of expressions
      (a.k.a. actions) which may be impure.
      The last expresion must have a type of I/O
      which means that all do blocks perform some I/O.
    </div>
    <pre>
- creates a block of monadic expressions
- is the value of the last expression the value of the do?
    </pre>

    <h4><a name="CommandLineArguments">Command Line Arguments</a></h4>
    <div>
    </div>

    <h4><a name="Files">Files</a></h4>
    <div>
    </div>

    <h4><a name="Streams">Streams</a></h4>
    <div>
    </div>

    <h4><a name="Bytestrings">Bytestrings</a></h4>
    <div>
    </div>

    <h4><a name=""></a></h4>
    <div>
    </div>

    <h3><a name="ExceptionHandling">Exception Handling</a></h3>
    <div>
      See http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/.
    </div>
    <pre>
- there are several approaches
  * use Either monad where
    the Left value is an exception description and
    the Right value is the success value
  * use catch from Control.Exception in one of these ways
    - use parens
      catch
        (do
          ...
        )
        handler
    - move handler to front
      (`catch` handler) $ do
        ...
    - use a helper function
      catch handler helper
        where helper = do
    </pre>
    <div>
      Here is an example of one way to deal with divide by zero errors.
    </div>
    <pre>
myDiv :: Float -> Float -> Either String Float
myDiv x 0 = Left "divide by zero"
myDiv x y = Right (x / y)
      
main :: IO ()
main = do
  let result = divSum 10 6 2 -- should be Right 8
  case result of
    Left err -> putStrLn $ "Error: " ++ err
    Right value -> print value</pre>

    <h3><a name="AdvancedTopics">Advanced Topics</a></h3>

    <h4><a name="Monoids">Monoids</a></h4>
    <div>
      <code>Monoid</code> is a type class
      defined in the <code>Prelude</code> module.
    </div>

    <h4><a name="Monads">Monads</a></h4>
    <div>
      <code>Monad</code> is a type class
      defined in the <code>Prelude</code> module.
    </div>
    <div>
      Monads can be used to isolate pure functions from impure functions.
      A monad is a type that supports bind and return functions.
      The return function creates a Monad instance that wraps a given value.
      The bind function extracts the value from a Monad instance.
    </div>
    <div>
      When calling a function that returns a Maybe,
      the Just value can be extracted with
      let (Just result) = someFunction
      in ...
      If someFunction returns Nothing, a runtime error will occur.
      Is this only reasonable to do in test code?
    </div>
    <pre>
  * "a way to structure computations in terms of values and
    sequences of computations using those values
    and returning monads"
  * can think of creating a monad as putting a value in a box
    and having a way to get the value out
  * three monad properties
    - modularity: allow computations to be composed of simpler computations
      and separate composition strategy from the computations
    - flexibility: allows computations to be easily reused
      with different composition strategies
    - isolation - isolates impure code (with side effects such as
      I/O and state modification) from pure code (no side effects)
  * a design pattern that defines how functions, actions, inputs, and outputs
    can be used together to build generic types with the following organization:
    - Define a data type, and how values of that data type are combined.
    - Create functions that use the data type, and compose them together
      into actions, following the rules defined in the first step
    - For example, the Maybe monad encapsulates variables which may have a
      null value, representing an option type, and automatically ensures that
      null values are not passed as arguments to functions that
      cannot handle them, serving as an alternative programming technique
      to throwing and catching exceptions when null values arise.
    - Another example is the List monad, where the empty list is a
      constant value of type List, and the cons operator binds a plain value
      as the head of a previous list.
  * many kinds of monads can be defined, but a small set are so
    commonly used that they are included in the Haskel standard library
    </pre>
    <div>
      Is it true that all functions that have a side effect
      must return a Monad?  If so, how is that enforced?
      Does this only apply to functions that
      perform I/O, may throw an exception, or modify state?
    </div>
    <table summary="Prelude monads">
      <caption>Prelude Monads</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Maybe</td>
        <td>
          supports error handling;
          has constructors Just and Nothing;
          Nothing typically represents an error condition;
          returned by List function lookup
        </td>
        <pre>
    - data Maybe a = Nothing | Just a
    - represents the result of a computation that may not return a result
    - "if a combined computation consists of one computation B
      that depends on the result of another computation A,
      then the combined computation should yield Nothing
      whenever either A or B yield Nothing and
      the combined computation should yield
      the result of B applied to the result of A
      when both computations succeed"
        </pre>
      </tr>
      <tr>
        <td>Either</td>
        <td>
          supports error handling;
          has constructors Left and Right;
          Right typically represents an error condition
        </td>
      </tr>
      <tr>
        <td>List</td>
        <td></td>
      </tr>
      <tr>
        <td>IO</td>
        <td></td>
      </tr>
      <tr>
        <td>State</td>
        <td>used to simulate mutability</td>
      </tr>
    </table>
    <div>
      The Data.Maybe library defines many functions that operate on Maybe values.
    </div>
    <table summary="Data.Maybe functions">
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
      <tr>
        <td><code>maybe</code></td>
        <td>
          This takes a default value, a function, and a Maybe value.
          If the Maybe value is Nothing, it returns the default value.
          If the Maybe value is a Just, it returns the result of
          applying the function to the value in the Just.
        </td>
      </tr>
      <tr>
        <td><code>isJust</code></td>
        <td>This takes a Maybe value and
          returns a Bool indicating whether it is a Just.</td>
      </tr>
      <tr>
        <td><code>isNothing</code></td>
        <td>This takes a Maybe value and
          returns a Bool indicating whetherif it is Nothing.</td>
      </tr>
      <tr>
        <td><code>fromJust</code></td>
        <td>This takes a Maybe value and
          returns the value if it is a Just
          or throws if it is Nothing.</td>
      </tr>
      <tr>
        <td><code>fromMaybe</code></td>
        <td>This takes a default value and a Maybe value.
          If the Maybe value is Nothing, it returns the default value.
          If the Maybe value is a Just, it returns the value in the Just.
        </td>
      </tr>
      <tr>
        <td><code>listToMaybe</code></td>
        <td>This takes a list.
          If the list is empty, it returns Nothing.
          Otherwise it returns a Just with the first element.
        </td>
      </tr>
      <tr>
        <td><code>maybeToList</code></td>
        <td>This takes a Maybe value.
          If the Maybe value is Nothing, it returns an empty list.
          Otherwise it returns a list containing only the Just value.
        </td>
      </tr>
      <tr>
        <td><code>catMaybes</code></td>
        <td>This takes a list of Maybe values
          and returns a list of all the Just values.</td>
      </tr>
      <tr>
        <td><code>mapMaybe</code></td>
        <td>This takes a function and a list.
          The function must take a value from the list and
          return a Maybe whose value is the result of some computation
          involving the value passed to it.
          It returns a list of the Just values
          in the Maybes returned by the function,
          ignoring the Nothing values.</td>
      </tr>
    </table>
    <div>
      In Haskell, the bind operation is performed
      with the infix function <code>>>=</code>.
      Its signature is
      (>>=) :: m a -> (a -> m b) -> m b
      where m represents the monad and a represents a normal value.
      m a is a normal value wrapped by the monad.
      This can be viewed as putting a in a box
      where the details of the box vary by monad.
      The bind function takes a monad wrapping a and a pure function.
      The function takes an a,
      does some calculation to create b from a,
      and returns b wrapped in the monad.
      The bind function does three things.
      First, it extracts a from the monad passed as the first argument.
      Second, it passes a to the function passed as the second argument.
      Third, it returns the result of that function result.
    </div>
    <div>
      Uses of the bind function can be chained to implement
      a complex computation from many simpler computations.
      For example, ...
    </div>
    <div>
      In Haskell, the return operation is performed
      with the <code>return</code> function.
      Its signature is
      return :: a -> m a
      where m represents the monad and a represents a normal value.
      It returns the result of wrapping a in the monad.
    </div>
    <div>
      <code>Maybe</code> is one of the simpler monads.
      Here is its Haskell implementation.
    </div>
    <pre>
data Maybe x = Just x | Nothing
return x = Just x</pre>
Nothing >>= f = Nothing
Just x >>= f = f x
    <div>
      This says that Maybe is a type class that includes two types,
      Just and Nothing where Just takes a value and Nothing does not.
      Think of Nothing as a box with nothing in it
      and Just as a box with one thing in it.
      The return function just takes a value and
      wraps it in one of the members of the <code>Maybe</code> type class,
      in this case a <code>Just</code>.
      When bind is called with a <code>Nothing</code> and any function,
      it always returns Nothing.
      When bind is called with a <code>Just</code> and a function
      that takes the value in the just and returns another <code>Just</code>,
      it extracts the value from the passed <code>Just</code>,
      calls the function on the value,
      and returns its result wrapped in a <code>Just</code>.
    </div>
    <div>
      Unless you have already studied monads, this probably seems complex.
      Why are monads a good thing?
      Let's consider a common operation and how it is handled in other programming languages.
      Division seems like a simple operation.
      However there are corner cases to consider.
      What if the dividend or divisor is "null"?
      What if the divisor is zero?
      In many programming languages an exception is thrown.
      It is up to the calling code to catch and correctly deal with those situations.
      When they are not correctly handled, software can crash at runtime,
      or worse, continue running with incorrect data.
      Monads provide a way to address these situations.
      And in languages with strict type checking, use of monads
      can required calling code to handle these situations.
      For example,
      show SafeDiv.hs
    </div>
    <div>
      <code>List</code> is another Haskell monad.
      Here is its Haskell implementation.
    </div>
    <pre>
return x = [x]
l >>= f = concatMap f l
    </pre>

    <h4><a name="Functors">Functors</a></h4>
    <div>
      <code>Functor</code> is a type class
      defined in the <code>Prelude</code> module.
    </div>

    <h4><a name="Applicatives">Applicatives</a></h4>
    <div>
      <code>Applicative</code> is a type that is
      an instance of the <code>Functor</code> type class
      defined in the <code>Prelude</code> module.
    </div>

    <h4><a name="Foldables">Foldables</a></h4>
    <div>
      <code>Foldable</code> is a type class
      defined in the <code>Prelude</code> module.
    </div>
    <table summary="Foldable functions">
      <caption>Foldable Functions</caption>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Example</th>
      </tr>
      <tr>
        <td>and</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>or</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>any</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>all</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>concat</td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td>concatMap</td>
        <td></td>
        <td></td>
      </tr>
    </table>

    <h4><a name="Traversables">Traversables</a></h4>
    <div>
      <code>Traversable</code> is a type
      defined in the <code>Prelude</code> module.
      It similar to <code>Foldable</code>,
      but also allows values to be added.
    </div>

    <h4><a name="Combinators">Combinators</a></h4>

    <h4><a name="Transducers">Transducers</a></h4>

    <h4><a name="Lenses">Lenses</a></h4>

    <h4><a name="HigherKindedTypes">Higher Kinded Types</a></h4>
    <div>
    </div>

    <h3><a name="ThingsIWouldChange">Things I Would Change</a></h3>
    <div>
      Likely nobody thinks Haskell is perfect
      and I am no exception.
      Here is a list of things about Haskell
      that I would change if I could:
    </div>
    <ul>
      <li>remove -> tokens from function type signatures</li>
      <li>drop the . and $ operators for changing evaluation order</li>
      <li>remove need to use commas in lists and tuples</li>
      <li>remove need to surround negative numbers with parens
        by saying that subtraction requires a space
        on both sides of <code>- and negation
        does not allow a space between - and the number
      </li>
      <li>don't require parens around type aliases
        when there is more than one</li>
      <li>change :: to : because where else is : used?</li>
    </ul>

    <h3><a name="Summary">Summary</a></h3>
    <div>
      This article covered everything you need to know to get started
      using Haskell.  Add more!
    </div>
    <div>
      Please send feedback on this article to
      <a href="mailto:mark@objectcomputing.com">mark@objectcomputing.com</a>.
    </div>

    <h3><a name="Acknowledgments">Acknowledgments</a></h3>
    <div>
      Many people helped me write this article
      by answering questions about Haskell or reviewing the article.
      In particularly I want to thank Rebecca Skinner,
      Charles Sharp (Object Computing, Inc.),
      and ?.
    </div>
    <div>
      For more articles like these, visit
      <a href="https://objectcomputing.com/resources/publications/sett/" target="_blank">https://objectcomputing.com/resources/publications/sett/</a>.
    </div>
  </body>
</html>

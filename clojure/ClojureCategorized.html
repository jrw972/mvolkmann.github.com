<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR.html1/DTD.html1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Clojure Categorized</title>
    <link rel="stylesheet" type="text/css" href="../common.css"/>
  </head>
  <body>
    <h2>Clojure Categorized</h2>
    <p>
      The following table categories Clojure
      functions, macros and special forms.
    </p>
    <table border="1">
      <tr>
        <th>Category</th>
        <th>Functions/Macros</th>
      </tr>
      <tr>
        <td>arrays - general</td>
        <td>
          aclone
          aget
          alength
          amap
          areduce
          aset
          into-array
          make-array
          to-array
          to-array-2d
        </td>
      </tr>
      <tr>
        <td>arrays - type-specific</td>
        <td>
          aset-boolean
          aset-byte
          aset-char
          aset-double
          aset-float
          aset-int
          aset-long
          aset-short
          double-array
          float-array
          int-array
          long-array
        </td>
      </tr>
      <tr>
        <td>bindings</td>
        <td>
          binding
          declare
          def
          defonce
          if-let
          let
          with-local-vars
        </td>
      </tr>
      <tr>
        <td>bitwise operations</td>
        <td>
          bit-and
          bit-and-not
          bit-clear
          bit-flip
          bit-not
          bit-or
          bit-set
          bit-shift-left
          bit-shift-right
          bit-test
          bit-xor
        </td>
      </tr>
      <tr>
        <td>Clojure code access</td>
        <td>
          load
          load-file
          load-reader
          load-string
          loaded-libs
          require
          source
          use
        </td>
      </tr>
      <tr>
        <td>compiling</td>
        <td>
          compile
          gen-class
          gen-interface
        </td>
      </tr>
      <tr>
        <td>conditional logic</td>
        <td>
          cond
          condp
          if
          if-let
          when
          when-first
          when-let
          when-not
        </td>
      </tr>
      <tr>
        <td>conversions</td>
        <td>
          bigdec
          bigint
          boolean
          byte
          char
          double
          float
          int
          long
          num
          short
        </td>
      </tr>
      <tr>
        <td>databases</td>
        <td>
          resultset-seq
          (also see clojure.contrib.sql)
        </td>
      </tr>
      <tr>
        <td>exception handling</td>
        <td>
          catch
          finally
          throw
          throw-if
          try
        </td>
      </tr>
      <tr>
        <td>functions</td>
        <td>
          comp
          complement
          constantly
          declare
          defn
          defn-
          fn
          partial
        </td>
      </tr>
      <tr>
        <td>multimethods</td>
        <td>
          defmethod
          defmulti
          prefer-method
          remove-method
        </td>
      </tr>
      <tr>
        <td>input/output</td>
        <td>
          file-seq
          flush
          line-seq
          newline
          pr
          prn
          print
          printf
          println
          read
          read-line
          slurp
          with-open
        </td>
      </tr>
      <tr>
        <td>iteration</td>
        <td>
          doseq
          dotimes
          for
          iterate
          loop/recur
          trampoline
          while
        </td>
      </tr>
      <tr>
        <td>Java interop.</td>
        <td>
          .
          ..
          add-classpath
          bean
          comparator
          enumeration-seq
          import
          iterator-seq
          memfn
          new
          set!
        </td>
      </tr>
      <tr>
        <td>Java interop. - proxies</td>
        <td>
          construct-proxy
          get-proxy-class
          proxy
          proxy-mappings
          proxy-super
          update-proxy
        </td>
      <tr>
        <td>list creation</td>
        <td>
          list
          list*
        </td>
      </tr>
      <tr>
        <td>predicates - logical</td>
        <td>
          and
          every?
          not
          not-any?
          not-every?
          or
          some
        </td>
      </tr>
      <tr>
        <td>predicates - relational</td>
        <td>
          <
          <=
          =
          ==
          >
          >=
          compare
          empty?
          false?
          identical?
          neg?
          nil?
          not=
          not-empty
          pos?
          true?
          zero?
        </td>
      </tr>
      <tr>
        <td>predicates - types</td>
        <td>
          associative?
          class?
          coll?
          decimal?
          delay?
          float?
          fn?
          ifn?
          instance?
          integer?
          keyword?
          list?
          macro?
          map?
          number?
          ratio?
          reversible?
          seq?
          sequential?
          set?
          sorted?
          string?
          symbol?
          var?
          vector?
        </td>
      </tr>
      <tr>
        <td>predicates - other</td>
        <td>
          distinct?
          even?
          odd?
        </td>
      </tr>
      <tr>
        <td>macros</td>
        <td>
          definline
          defmacro
          macro?
          macroexpand
          macroexpand-1
        </td>
      </tr>
      <tr>
        <td>map operations</td>
        <td>
          array-map
          assoc
          assoc-in
          contains?
          dissoc
          find
          get
          hash-map
          key
          keys
          max-key
          merge
          merge-with
          min-key
          pmap
          select-keys
          sorted-map
          sorted-map-by
          update-in
          val
          vals
          zip-map
        </td>
      </tr>
      <tr>
        <td>math - general</td>
        <td>
          +
          -
          *
          /
          dec
          inc
          max
          min
          quot
          rand
          rand-int
          rationalize
          rem
          with-precision
        </td>
      </tr>
      <tr>
        <td>math - unchecked</td>
        <td>
          unchecked-add
          unchecked-dec
          unchecked-divide
          unchecked-inc
          unchecked-multiply
          unchecked-negate
          unchecked-remainder
          unchecked-subtract
        </td>
      </tr>
      <tr>
        <td>metadata</td>
        <td>
          meta
          with-meta
        </td>
      </tr>
      <tr>
        <td>namespaces</td>
        <td>
          alias
          all-ns
          create-ns
          find-ns
          find-var
          in-ns
          namespace
          ns
          ns-aliases
          ns-imports
          ns-interns
          ns-map
          ns-name
          ns-publics
          ns-refers
          ns-resolve
          ns-unalias
          ns-unmap
          refer
          refer-clojure
          remove-ns
          resolve
          the-ns
          use
        </td>
      </tr>
      <tr>
        <td>parallel operations (in clojure.parallel namespace)</td>
        <td>
          pany
          par
          pdistinct
          pfilter-dupes
          pfilter-nils
          pmax
          pmin
          preduce
          psort
          psummary
          pvec
        </td>
      </tr>
      <tr>
        <td>quoting and unquoting (evaluating)</td>
        <td>
          eval
          quote
        </td>
      </tr>
      <tr>
        <td>reflection</td>
        <td>
          ancestors
          bases
          class
          doc
          find-doc
          instance?
          isa?
          ns-resolve
          parents
          special-symbol?
          supers
        </td>
      </tr>
      <tr>
        <td>reference types - all</td>
        <td>
          set-validator
        </td>
      </tr>
      <tr>
        <td>reference types - agents</td>
        <td>
          agent
          agent-errors
          await
          await-for
          clear-agent-errors
          send
          send-off
          shutdown-agents
        </td>
      </tr>
      <tr>
        <td>reference types - agents as watchers</td>
        <td>
          add-watch
          add-watcher
          remove-watch
        </td>
      </tr>
      <tr>
        <td>reference types - atoms</td>
        <td>
          atom
          compare-and-set!
          reset!
          swap!
        </td>
      </tr>
      <tr>
        <td>reference types - refs</td>
        <td>
          alter
          commute
          dosync
          ref
          ref-set
        </td>
      </tr>
      <tr>
        <td>reference types - vars</td>
        <td>
          alter-var-root
          def
          set!
          var
          var?
          var-get
          var-set
        </td>
      </tr>
      <tr>
        <td>regular expressions</td>
        <td>
          re-find
          re-groups
          re-matcher
          re-matches
          re-pattern
          re-seq
        </td>
      </tr>
      <tr>
        <td>sequence operations to retrieve a single item</td>
        <td>
          ffirst
          first
          fnext
          last
          nth
          peek
          second
        </td>
      </tr>
      <tr>
        <td>sequence operations to retrieve multiple items</td>
        <td>
          butlast
          drop
          drop-last
          drop-while
          filter
          next
          nnext
          nthnext
          pop
          remove
          rest
          rseq
          rsubseq
          subseq
          take
          take-nth
          take-while
        </td>
      </tr>
      <tr>
        <td>sequence operations to do other things</td>
        <td>
          apply
          cache-seq
          concat
          conj
          cons
          count
          cycle
          distinct
          doall
          dorun
          empty
          <i>flatten</i>
          fnseq
          iterate
          interleave
          interpose
          into
          lazy-cat
          lazy-cons
          map
          mapcat
          partition
          range
          repeat
          repeatedly
          replace
          replicate
          reverse
          seq
          seque
          sort
          sort-by
          split-at
          split-with
          tree-seq
        </td>
      </tr>
      <tr>
        <td>set operations in clojure.core namespace</td>
        <td>
          disj
          hash-set
          set
          set?
          sorted-set
        </td>
      </tr>
      <tr>
        <td>set operations in clojure.set namespace</td>
        <td>
          difference
          index
          intersection
          join
          map-invert
          project
          rename
          rename-keys
          select
          union
        </td>
      </tr>
      <tr>
        <td>string and character operations</td>
        <td>
          char-escape-string
          char-name-string
          format
          pr-str
          print-str
          prn-str
          read-string
          str
          string?
          subs
          with-in-str
          with-out-str
        </td>
      </tr>
      <tr>
        <td>structs</td>
        <td>
          accessor
          create-struct
          defstruct
          get-in
          struct
          struct-map
        </td>
      </tr>
      <tr>
        <td>testing</td>
        <td>
          assert
          cast
          test
        </td>
      </tr>
      <tr>
        <td>threads and concurrency</td>
        <td>
          agent-errors
          clear-agent-errors
          future
          future-call
          get-validator
          locking
          monitor-enter
          monitor-exit
        </td>
      </tr>
      <tr>
        <td>transactions and refs</td>
        <td>
          alter
          commute
          deref
          dosync
          ensure
          ref
          sync
        </td>
      </tr>
      <tr>
        <td>trees (in clojure.zip namespace)</td>
        <td>
          append-child
          branch?
          children
          down
          edit
          end?
          insert-child
          insert-left
          insert-right
          left
          lefts
          make-node
          next
          node
          path
          remove
          replace
          right
          rights
          root
          seq-zip
          up
          vector-zip
          xml-zip
          zipper
        </td>
      </tr>
      <tr>
        <td>type hierarchies</td>
        <td>
          derive
          isa?
          make-hierarchy
          underive
        </td>
      </tr>
      <tr>
        <td>vector operations</td>
        <td>
          get
          nth
          split-at
          split-with
          subvec
          vec
          vector
          vector?
        </td>
      </tr>
      <tr>
        <td>XML</td>
        <td>
          parse (in clojure.xml namespace)
          xml-seq
        </td>
      </tr>
      <tr>
        <td>miscellaneous</td>
        <td>
          ->
          comment
          delay
          delay?
          descendants
          do
          doto
          force
          gensym
          hash
          identity
          intern
          keyword
          name
          preduce
          reduce
          symbol
          time
        </td>
      </tr>
    </table>

    <hr />
    <p style="text-align:center">
      Copyright &#169; 2009 Object Computing, Inc. All rights reserved.
    </p>
  </body>
</html>
